    colors = vtk.vtkNamedColors()

    colors.SetColor("BkgColor", [26, 51, 102, 255])

    parametricObjects = list()
    parametricObjects.append(vtk.vtkParametricBohemianDome())
--
    textProperty = vtk.vtkTextProperty()
    textProperty.SetFontSize(12)
    textProperty.SetJustificationToCentered()

    backProperty = vtk.vtkProperty()
    backProperty.SetColor(colors.GetColor3d("Tomato"))

    # Create a parametric function source, renderer, mapper, and actor
    # for each object
    for i in range(0, len(parametricObjects)):
--
    renderWindow = vtk.vtkRenderWindow()
    renderWindow.SetWindowName("Parametric Objects Demonstration2")
    renderWindow.SetSize(rendererSize * xGridDimensions,
                         rendererSize * yGridDimensions)
    for row in range(0, yGridDimensions):
        for col in range(0, xGridDimensions):
--
                ren = vtk.vtkRenderer()
                ren.SetBackground(colors.GetColor3d("BkgColor"))
                ren.SetViewport(viewport)
                renderWindow.AddRenderer(ren)
                continue

--
    interactor = vtk.vtkRenderWindowInteractor()
    interactor.SetRenderWindow(renderWindow)

    renderWindow.Render()
    interactor.Start()

--
    colors = vtk.vtkNamedColors()

    colors.SetColor("BkgColor", [26, 51, 102, 255])

    parametricObjects = list()
    parametricObjects.append(vtk.vtkParametricBoy())
--
    inputPoints = vtk.vtkPoints()
    rng = vtk.vtkMinimalStandardRandomSequence()
    rng.SetSeed(8775070)
    for i in range(0, 10):
        rng.Next()
        x = rng.GetRangeValue(0.0, 1.0)
        rng.Next()
--
    textProperty = vtk.vtkTextProperty()
    textProperty.SetFontSize(12)
    textProperty.SetJustificationToCentered()

    backProperty = vtk.vtkProperty()
    backProperty.SetColor(colors.GetColor3d("Tomato"))

    # Create a parametric function source, renderer, mapper, and actor
    # for each object
    for i in range(0, len(parametricObjects)):
--
    renderWindow = vtk.vtkRenderWindow()
    renderWindow.SetWindowName("Parametric Objects Demonstration")
    renderWindow.SetSize(rendererSize * xGridDimensions, rendererSize * yGridDimensions)
    for row in range(0, yGridDimensions):
        for col in range(0, xGridDimensions):
            index = row * xGridDimensions + col
--
                ren = vtk.vtkRenderer()
                ren.SetBackground(colors.GetColor3d("BkgColor"))
                ren.SetViewport(viewport)
                renderWindow.AddRenderer(ren)
                continue

--
    interactor = vtk.vtkRenderWindowInteractor()
    interactor.SetRenderWindow(renderWindow)

    renderWindow.Render()
    interactor.Start()

--
    colors = vtk.vtkNamedColors()

    colors.SetColor("BkgColor", [26, 51, 102, 255])

    # Uncomment one of the following.
    # parametricObject = vtk.vtkParametricBoy()
    # parametricObject = vtk.vtkParametricConicSpiral()
    # parametricObject = vtk.vtkParametricCrossCap()
    # parametricObject = vtk.vtkParametricDini()
    # parametricObject = vtk.vtkParametricEllipsoid()
    # parametricObject = vtk.vtkParametricEnneper()
    parametricObject = vtk.vtkParametricFigure8Klein()
    # parametricObject = vtk.vtkParametricKlein()
    # parametricObject = vtk.vtkParametricMobius()
    # parametricObject = vtk.vtkParametricRandomHills()
    # parametricObject = vtk.vtkParametricRoman()
    # parametricObject = vtk.vtkParametricSpline()
    # parametricObject = vtk.vtkParametricSuperEllipsoid()
    # parametricObject = vtk.vtkParametricSuperToroid()
    # parametricObject = vtk.vtkParametricTorus()

    parametricFunctionSource = vtk.vtkParametricFunctionSource()
    parametricFunctionSource.SetParametricFunction(parametricObject)
    parametricFunctionSource.Update()

    # Visualize
    backProperty = vtk.vtkProperty()
    backProperty.SetColor(colors.GetColor3d("Tomato"))

    mapper = vtk.vtkPolyDataMapper()
    mapper.SetInputConnection(parametricFunctionSource.GetOutputPort())

    # Create an actor for the contours
    actor = vtk.vtkActor()
    actor.SetMapper(mapper)
    actor.GetProperty().SetColor(colors.GetColor3d("Banana"))
    actor.GetProperty().SetSpecular(.5)
    actor.GetProperty().SetSpecularPower(20)
    actor.SetBackfaceProperty(backProperty)
    renderer = vtk.vtkRenderer()
    renderWindow = vtk.vtkRenderWindow()
    renderWindow.SetWindowName("Parametric Objects")
    renderWindow.AddRenderer(renderer)
    interactor = vtk.vtkRenderWindowInteractor()
    interactor.SetRenderWindow(renderWindow)

    renderer.AddActor(actor)
    renderer.SetBackground(colors.GetColor3d("BkgColor"))

--
    colors = vtk.vtkNamedColors()

    g = vtk.vtkMutableDirectedGraph()
    latitude = vtk.vtkDoubleArray()
    latitude.SetName('latitude')
    longitude = vtk.vtkDoubleArray()
    longitude.SetName('longitude')
    for i in range(-90, 90, 10):
        for j in range(-180, 180, 20):
            g.AddVertex()
            latitude.InsertNextValue(i)
--
    assign = vtk.vtkGeoAssignCoordinates()
    assign.SetInputData(g)

    assign.SetLatitudeArrayName('latitude')
    assign.SetLongitudeArrayName('longitude')
    assign.SetGlobeRadius(1.0)
--
    mapper = vtk.vtkGraphMapper()
    mapper.SetInputConnection(assign.GetOutputPort())
    actor = vtk.vtkActor()
    actor.SetMapper(mapper)
    ren = vtk.vtkRenderer()
    ren.AddActor(actor)
    iren = vtk.vtkRenderWindowInteractor()
    renWin = vtk.vtkRenderWindow()
    renWin.AddRenderer(ren)
    renWin.SetInteractor(iren)
    ren.SetBackground(colors.GetColor3d('MidnightBlue'))
    ren.ResetCamera()
    ren.GetActiveCamera().SetPosition(-1.02, -4.6, 3.45)
--
    colors = vtk.vtkNamedColors()

    geoGraticle = vtk.vtkGeoGraticule()
    transformProjection = vtk.vtkGeoTransform()
    destinationProjection = vtk.vtkGeoProjection()
    sourceProjection = vtk.vtkGeoProjection()
    transformGraticle = vtk.vtkTransformFilter()

    reader = vtk.vtkXMLPolyDataReader()
    transformReader = vtk.vtkTransformFilter()
    graticleMapper = vtk.vtkPolyDataMapper()
    readerMapper = vtk.vtkPolyDataMapper()
    graticleActor = vtk.vtkActor()
    readerActor = vtk.vtkActor()

    geoGraticle.SetGeometryType(geoGraticle.POLYLINES)
    geoGraticle.SetLatitudeLevel(2)
    geoGraticle.SetLongitudeLevel(2)
    geoGraticle.SetLongitudeBounds(-180, 180)
--
    renderWindow = vtk.vtkRenderWindow()
    renderer = vtk.vtkRenderer()
    interactor = vtk.vtkRenderWindowInteractor()
    renderWindow.SetInteractor(interactor)
    renderWindow.AddRenderer(renderer)
    renderWindow.SetSize(640, 480)
    renderer.SetBackground(colors.GetColor3d('BurlyWood'))

--
    description = 'Building a graph using Unstructured Grid & dumping it into a vtk file.'
    epilogue = '''
        Building a graph using Unstructured Grid & dumping it into a vtk file, to be visualized using ParaView.
        
        The generated file can then be used in ParaView/VisIt.
   '''
--
    parser.add_argument('filename', help='A required vtk filename, e.g. vertex.vtu.', nargs='?', const='vertex.vtu',
                        type=str, default='testVertex.vtu')
    args = parser.parse_args()
    return args.filename


--
    pointSource = vtkPointSource()
    pointSource.Update()

    # Create an integer array to store vertex id data & link it with its degree value as a scalar.
    degree = vtkIntArray()
    degree.SetNumberOfComponents(1)
    degree.SetName('degree')
    degree.SetNumberOfTuples(7)
    degree.SetValue(0, 2)
    degree.SetValue(1, 1)
--
    Points = vtkPoints()
    Points.InsertNextPoint(0, 1, 0)
    Points.InsertNextPoint(0, 0, 0)
    Points.InsertNextPoint(1, 1, 0)
    Points.InsertNextPoint(1, 0, 0)
    Points.InsertNextPoint(2, 1, 0)
--
    line = vtkCellArray()
    line.Allocate(8)
    line.InsertNextCell(2)
    line.InsertCellPoint(0)
    line.InsertCellPoint(1)
    line.InsertNextCell(2)
--
    G = vtkUnstructuredGrid()
    G.GetPointData().SetScalars(degree)
    G.SetPoints(Points)
    G.SetCells(VTK_LINE, line)

    # Dump the graph in VTK unstructured format (.vtu)
    gw = vtkXMLUnstructuredGridWriter()
    gw.SetFileName(fn)
    gw.SetInputData(G)
    gw.Write()
    print('---> ')

--
    parser.add_argument('filename', help='A required vtk filename, e.g. writeImageData.vti.', nargs='?',
                        const='writeImageData.vti',
                        type=str, default='writeImageData.vti')
    args = parser.parse_args()
    return args.filename

--
    colors = vtkNamedColors()

    filename = get_program_parameters()

    imageData = vtkImageData()
    imageData.SetDimensions(3, 4, 5)
    imageData.AllocateScalars(VTK_DOUBLE, 1)

    dims = imageData.GetDimensions()

--
    writer = vtkXMLImageDataWriter()
    writer.SetFileName(filename)
    writer.SetInputData(imageData)
    writer.Write()

    # Read the file (to test that it was written correctly)
    reader = vtkXMLImageDataReader()
    reader.SetFileName(filename)
    reader.Update()

    # Convert the image to a polydata
    imageDataGeometryFilter = vtkImageDataGeometryFilter()
    imageDataGeometryFilter.SetInputConnection(reader.GetOutputPort())
    imageDataGeometryFilter.Update()

    mapper = vtkPolyDataMapper()
    mapper.SetInputConnection(imageDataGeometryFilter.GetOutputPort())

    actor = vtkActor()
    actor.SetMapper(mapper)
    actor.GetProperty().SetPointSize(3)

    # Setup rendering
    renderer = vtkRenderer()
    renderer.AddActor(actor)
    renderer.SetBackground(colors.GetColor3d('White'))
    renderer.ResetCamera()

    renderWindow = vtkRenderWindow()
    renderWindow.AddRenderer(renderer)

    renderWindowInteractor = vtkRenderWindowInteractor()

    renderWindowInteractor.SetRenderWindow(renderWindow)
    renderWindowInteractor.Initialize()
    renderWindowInteractor.Start()

--
    poly_data = vtkPolyData()
    points = vtkPoints()
    points.SetData(numpy_support.numpy_to_vtk(xyz))
    poly_data.SetPoints(points)

    # Set an index
    idx = numpy_support.numpy_to_vtk(elev)
    idx.SetName('Index')
    poly_data.GetPointData().AddArray(idx)

    # We use the elevation as the active scalars.
    scal = numpy_support.numpy_to_vtk(elev)
    scal.SetName('Elevation(m)')
    poly_data.GetPointData().SetScalars(scal)
    poly_data.GetPointData().SetActiveScalars('Elevation(m)')
    elev_range = poly_data.GetPointData().GetScalars().GetRange()

--
    poly_line = vtkPolyLine()
    poly_line.GetPointIds().SetNumberOfIds(num_pts)
    for i in range(0, num_pts):
        poly_line.GetPointIds().SetId(i, i)

    # Create a cell array to store the lines in and add the lines to it.
    cells = vtkCellArray()
    cells.InsertNextCell(poly_line)

    # Add the lines to the dataset
    poly_data.SetLines(cells)

--
    transform = vtkTransform()
    if utm:
        # Scale the elevation.
        transform.Scale(1, 1, 1)
    if ecef:
        # Rotate the ECEF coordinates
--
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputDataObject(poly_data)
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    if vtp:
        writer = vtkXMLPolyDataWriter()
        writer.SetFileName(vtp_fn)
        writer.SetInputConnection(transform_filter.GetOutputPort())
        writer.SetDataModeToBinary()
        writer.Write()

    colors = vtkNamedColors()
    colors.SetColor("ParaViewBkg", [82, 87, 110, 255])

    lut = get_diverging_lut('cool_warm')
    # lut = get_diverging_lut1('DarkRed', 'Gainsboro', 'Green')

    mapper = vtkPolyDataMapper()
    mapper.SetInputConnection(transform_filter.GetOutputPort())
    mapper.SetScalarRange(elev_range)
    mapper.SetLookupTable(lut)
    mapper.ScalarVisibilityOn()

    actor = vtkActor()
    actor.SetMapper(mapper)

    window_width = 1024
    window_height = 1024

--
    scalar_bar = vtkScalarBarActor()
    scalar_bar.SetLookupTable(mapper.GetLookupTable())
    scalar_bar.SetTitle('Elevation')
    scalar_bar.UnconstrainedFontSizeOff()
    scalar_bar.SetNumberOfLabels(6)
    scalar_bar.SetVerticalTitleSeparation(50)
--
    renderer = vtkRenderer()
    ren_win = vtkRenderWindow()
    ren_win.AddRenderer(renderer)
    ren_win.SetSize(window_width, window_height)
    if ecef:
        ren_win.SetWindowName('ECEF')
    elif utm:
--
    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(ren_win)
    style = vtkInteractorStyleTrackballCamera()
    iren.SetInteractorStyle(style)

    renderer.AddActor(actor)
    renderer.AddActor(scalar_bar)
    renderer.SetBackground(colors.GetColor3d('ParaViewBkg'))
--
    cam_orient_manipulator = vtkCameraOrientationWidget()
    cam_orient_manipulator.SetParentRenderer(renderer)
    cam_orient_manipulator.On()

    axes = vtkAxesActor()
    axes.SetXAxisLabelText('East')
    axes.SetYAxisLabelText('North')
    # Zenith
    axes.SetZAxisLabelText('Zenith')

    widget = vtkOrientationMarkerWidget()
    rgba = [0] * 4
    colors.GetColor('Carrot', rgba)
    widget.SetOutlineColor(rgba[0], rgba[1], rgba[2])
    widget.SetOrientationMarker(axes)
    widget.SetInteractor(iren)
--
    ctf = vtkColorTransferFunction()
    ctf.SetColorSpaceToDiverging()
    cm = color_maps[color_map]

    ctf.AddRGBPoint(0.0, *cm['start'])
    ctf.AddRGBPoint(0.5, *cm['mid'])
--
    lut = vtkLookupTable()
    lut.SetNumberOfTableValues(table_size)
    lut.Build()

    for i in range(0, table_size):
        rgba = list(ctf.GetColor(float(i) / table_size))
--
    colors = vtkNamedColors()
    # Colour transfer function.
    ctf = vtkColorTransferFunction()
    ctf.SetColorSpaceToDiverging()
    p1 = [0.0] + list(colors.GetColor3d(start))
    p2 = [0.5] + list(colors.GetColor3d(mid))
    p3 = [1.0] + list(colors.GetColor3d(end))
    ctf.AddRGBPoint(*p1)
--
    lut = vtkLookupTable()
    lut.SetNumberOfTableValues(table_size)
    lut.Build()

    for i in range(0, table_size):
        rgba = list(ctf.GetColor(float(i) / table_size))
--
    colors = vtk.vtkNamedColors()

    file_name = get_program_parameters()

    # Read the source file.
    reader = vtk.vtkXMLUnstructuredGridReader()
    reader.SetFileName(file_name)
    reader.Update()  # Needed because of GetScalarRange
    output = reader.GetOutput()
    # scalar_range = output.GetScalarRange()

--
    mapper = vtk.vtkDataSetMapper()
    mapper.SetInputData(output)
    # mapper.SetScalarRange(scalar_range)
    mapper.ScalarVisibilityOff()

    # Create the Actor
    actor = vtk.vtkActor()
    actor.SetMapper(mapper)
    actor.GetProperty().EdgeVisibilityOn()
    actor.GetProperty().SetLineWidth(2.0)
    actor.GetProperty().SetColor(colors.GetColor3d("MistyRose"))

    backface = vtk.vtkProperty()
    backface.SetColor(colors.GetColor3d('Tomato'))
    actor.SetBackfaceProperty(backface)

    # Create the Renderer
    renderer = vtk.vtkRenderer()
    renderer.AddActor(actor)
    renderer.SetBackground(colors.GetColor3d('Wheat'))

    # Create the RendererWindow
    renderer_window = vtk.vtkRenderWindow()
    renderer_window.SetSize(640, 480)
    renderer_window.AddRenderer(renderer)
    renderer_window.SetWindowName('ReadUnstructuredGrid')

    # Create the RendererWindowInteractor and display the vtk_file
    interactor = vtk.vtkRenderWindowInteractor()
    interactor.SetRenderWindow(renderer_window)
    interactor.Initialize()
    interactor.Start()


--
        writer = vtkUnstructuredGridWriter()
        writer.SetFileName(filenames[i])
        writer.SetInputData(uGrids[i])
        writer.Write()


--
    ug = vtkUnstructuredGrid()
    ug.SetPoints(aCell.GetPoints())
    ug.InsertNextCell(aCell.GetCellType(), aCell.GetPointIds())
    return ug


--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, 0, 0)
    points.InsertNextPoint(0, 1, 0)
    points.InsertNextPoint(0, 0, 1)
    points.InsertNextPoint(1, 0, .4)
--
    polyVertex = vtkPolyVertex()
    polyVertex.GetPointIds().SetNumberOfIds(numberOfVertices)

    for i in range(0, numberOfVertices):
        polyVertex.GetPointIds().SetId(i, i)

    ug = vtkUnstructuredGrid()
    ug.SetPoints(points)
    ug.InsertNextCell(polyVertex.GetCellType(), polyVertex.GetPointIds())

    return ug

--
    points = vtkPoints()
    points.InsertNextPoint(0, .5, 0)
    points.InsertNextPoint(.5, 0, 0)
    points.InsertNextPoint(1, .3, 0)
    points.InsertNextPoint(1.5, .4, 0)
    points.InsertNextPoint(2.0, .4, 0)
--
    polyline = vtkPolyLine()
    polyline.GetPointIds().SetNumberOfIds(numberOfVertices)

    for i in range(0, numberOfVertices):
        polyline.GetPointIds().SetId(i, i)

    ug = vtkUnstructuredGrid()
    ug.SetPoints(points)
    ug.InsertNextCell(polyline.GetCellType(), polyline.GetPointIds())

    return ug

--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(.5, 1, 0)
    points.InsertNextPoint(1, -.1, 0)
    points.InsertNextPoint(1.5, .8, 0)
    points.InsertNextPoint(2.0, -.1, 0)
--
    trianglestrip = vtkTriangleStrip()
    trianglestrip.GetPointIds().SetNumberOfIds(numberOfVertices)
    for i in range(0, numberOfVertices):
        trianglestrip.GetPointIds().SetId(i, i)

    ug = vtkUnstructuredGrid()
    ug.SetPoints(points)
    ug.InsertNextCell(trianglestrip.GetCellType(), trianglestrip.GetPointIds())

    return ug

--
    points = vtkPoints()
    points.InsertNextPoint(0, 0, 0)
    points.InsertNextPoint(1, -.1, 0)
    points.InsertNextPoint(.8, .5, 0)
    points.InsertNextPoint(1, 1, 0)
    points.InsertNextPoint(.6, 1.2, 0)
--
    polygon = vtkPolygon()
    polygon.GetPointIds().SetNumberOfIds(numberOfVertices)
    for i in range(0, numberOfVertices):
        polygon.GetPointIds().SetId(i, i)

    ug = vtkUnstructuredGrid()
    ug.SetPoints(points)
    ug.InsertNextCell(polygon.GetCellType(), polygon.GetPointIds())

    return ug

--
    colors = vtkNamedColors()
    backgroundColor = colors.GetColor3d('steel_blue')
    boundaryColor = colors.GetColor3d('Banana')
    clipColor = colors.GetColor3d('Tomato')

    if filePath and os.path.isfile(filePath):
--
    plane = vtkPlane()
    plane.SetOrigin(polyData.GetCenter())
    plane.SetNormal(1.0, -1.0, -1.0)

    clipper = vtkClipPolyData()
    clipper.SetInputData(polyData)
    clipper.SetClipFunction(plane)
    clipper.SetValue(0)
    clipper.Update()

--
    clipMapper = vtkDataSetMapper()
    clipMapper.SetInputData(polyData)

    clipActor = vtkActor()
    clipActor.SetMapper(clipMapper)
    clipActor.GetProperty().SetDiffuseColor(clipColor)
    clipActor.GetProperty().SetInterpolationToFlat()
    clipActor.GetProperty().EdgeVisibilityOn()

--
    boundaryEdges = vtkFeatureEdges()
    boundaryEdges.SetInputData(polyData)
    boundaryEdges.BoundaryEdgesOn()
    boundaryEdges.FeatureEdgesOff()
    boundaryEdges.NonManifoldEdgesOff()
    boundaryEdges.ManifoldEdgesOff()
--
    boundaryStrips = vtkStripper()
    boundaryStrips.SetInputConnection(boundaryEdges.GetOutputPort())
    boundaryStrips.Update()

    # Change the polylines into polygons
    boundaryPoly = vtkPolyData()
    boundaryPoly.SetPoints(boundaryStrips.GetOutput().GetPoints())
    boundaryPoly.SetPolys(boundaryStrips.GetOutput().GetLines())

    boundaryMapper = vtkPolyDataMapper()
    boundaryMapper.SetInputData(boundaryPoly)

    boundaryActor = vtkActor()
    boundaryActor.SetMapper(boundaryMapper)
    boundaryActor.GetProperty().SetDiffuseColor(boundaryColor)

    # create renderer render window, and interactor
    renderer = vtkRenderer()
    renderWindow = vtkRenderWindow()
    renderWindow.AddRenderer(renderer)
    interactor = vtkRenderWindowInteractor()
    interactor.SetRenderWindow(renderWindow)

    # set background color and size
    renderer.SetBackground(backgroundColor)
    renderWindow.SetSize(640, 480)
--
        reader = vtkPLYReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtp':
        reader = vtkXMLpoly_dataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.obj':
        reader = vtkOBJReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.stl':
        reader = vtkSTLReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtk':
        reader = vtkpoly_dataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.g':
        reader = vtkBYUReader()
        reader.SetGeometryFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    else:
        # Return a None if the extension is unknown.
--
    source = vtkSphereSource()
    source.SetThetaResolution(20)
    source.SetPhiResolution(11)
    source.Update()
    return source.GetOutput()

--
    colors = vtkNamedColors()
    backFaceColor = colors.GetColor3d('Gold')
    inputActorColor = colors.GetColor3d('NavajoWhite')
    decimatedActorColor = colors.GetColor3d('NavajoWhite')
    # colors.SetColor('leftBkg', [0.6, 0.5, 0.4, 1.0])
    # colors.SetColor('rightBkg', [0.4, 0.5, 0.6, 1.0])
--
            triangles = vtkTriangleFilter()
            triangles.SetInputData(readerPD)
            triangles.Update()
            inputPolyData = triangles.GetOutput()
    else:
        inputPolyData = GetSpherePD()
--
    decimate = vtkDecimatePro()
    decimate.SetInputData(inputPolyData)
    decimate.SetTargetReduction(reduction)
    decimate.PreserveTopologyOn()
    decimate.Update()

    decimated = vtkPolyData()
    decimated.ShallowCopy(decimate.GetOutput())

    print('After decimation')
    print(f'There are {decimated.GetNumberOfPoints()} points.')
    print(f'There are {decimated.GetNumberOfPolys()} polygons.')
--
    inputMapper = vtkPolyDataMapper()
    inputMapper.SetInputData(inputPolyData)

    backFace = vtkProperty()
    backFace.SetColor(backFaceColor)

    inputActor = vtkActor()
    inputActor.SetMapper(inputMapper)
    inputActor.GetProperty().SetInterpolationToFlat()
    inputActor.GetProperty().SetColor(inputActorColor)
    inputActor.SetBackfaceProperty(backFace)

    decimatedMapper = vtkPolyDataMapper()
    decimatedMapper.SetInputData(decimated)

    decimatedActor = vtkActor()
    decimatedActor.SetMapper(decimatedMapper)
    decimatedActor.GetProperty().SetColor(decimatedActorColor)
    decimatedActor.GetProperty().SetInterpolationToFlat()
    decimatedActor.SetBackfaceProperty(backFace)

--
    renderWindow = vtkRenderWindow()
    renderWindow.SetSize(600, 300)
    renderWindow.SetWindowName('Decimation');

    # And one interactor
    interactor = vtkRenderWindowInteractor()
    interactor.SetRenderWindow(renderWindow)

    # Define viewport ranges
    # (xmin, ymin, xmax, ymax)
    leftViewport = [0.0, 0.0, 0.5, 1.0]
--
    leftRenderer = vtkRenderer()
    renderWindow.AddRenderer(leftRenderer)
    leftRenderer.SetViewport(leftViewport)
    # leftRenderer.SetBackground((colors.GetColor3d('leftBkg')))
    leftRenderer.SetBackground((colors.GetColor3d('Peru')))

    rightRenderer = vtkRenderer()
    renderWindow.AddRenderer(rightRenderer)
    rightRenderer.SetViewport(rightViewport)
    # rightRenderer.SetBackground((colors.GetColor3d('rightBkg')))
    rightRenderer.SetBackground((colors.GetColor3d('CornflowerBlue')))

--
    camera = vtkCamera()
    camera.SetPosition(0, -1, 0)
    camera.SetFocalPoint(0, 0, 0)
    camera.SetViewUp(0, 0, 1)
    camera.Elevation(30)
    camera.Azimuth(30)
--
        reader = vtkPLYReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtp':
        reader = vtkXMLPolyDataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.obj':
        reader = vtkOBJReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.stl':
        reader = vtkSTLReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtk':
        reader = vtkPolyDataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.g':
        reader = vtkBYUReader()
        reader.SetGeometryFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    else:
        # Return a None if the extension is unknown.
--
    source = vtkSphereSource()
    source.SetThetaResolution(30)
    source.SetPhiResolution(15)
    source.Update()
    return source.GetOutput()

--
    use_flying_edges = vtk_version_ok(8, 2, 0)

    colors = vtkNamedColors()

    colors.SetColor('SkinColor', [240, 184, 160, 255])
    colors.SetColor('BackfaceColor', [255, 229, 200, 255])
    colors.SetColor('BkgColor', [51, 77, 102, 255])

--
    reader = vtkStructuredPointsReader()
    reader.SetFileName(file_name)

    # Create a 3D model using flying edges or marching cubes
    if use_flying_edges:
        try:
            mc = vtkFlyingEdges3D()
        except AttributeError:
            mc = vtkMarchingCubes()
    else:
        mc = vtkMarchingCubes()

    mc.SetInputConnection(reader.GetOutputPort())
    mc.ComputeNormalsOn()
    mc.ComputeGradientsOn()
    mc.SetValue(0, threshold)  # second value acts as threshold
--
    confilter = vtkPolyDataConnectivityFilter()
    confilter.SetInputConnection(mc.GetOutputPort())
    confilter.SetExtractionModeToLargestRegion()

    # Create a mapper
    mapper = vtkPolyDataMapper()
    if largest_surface:
        mapper.SetInputConnection(confilter.GetOutputPort())
    else:
        mapper.SetInputConnection(mc.GetOutputPort())
    mapper.ScalarVisibilityOff()
--
    actor = vtkActor()
    actor.GetProperty().SetColor(colors.GetColor3d('SkinColor'))
    back_prop = vtkProperty()
    back_prop.SetDiffuseColor(colors.GetColor3d('BackfaceColor'))
    actor.SetBackfaceProperty(back_prop)
    actor.SetMapper(mapper)

    renderer = vtkRenderer()
    renderer.AddActor(actor)
    renderer.SetBackground(colors.GetColor3d('SlateGray'))
    renderer.GetActiveCamera().SetViewUp(0.0, 0.0, 1.0)
    renderer.GetActiveCamera().SetPosition(0.0, 1.0, 0.0)
    renderer.GetActiveCamera().SetFocalPoint(0.0, 0.0, 0.0)
--
    ren_win = vtkRenderWindow()
    ren_win.AddRenderer(renderer)
    ren_win.SetSize(640, 480)
    ren_win.SetWindowName('ExtractLargestIsosurface')

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(ren_win)
    ren_win.Render()
    iren.Initialize()
    iren.Start()

--
    description = 'Reads a structured points dataset stored in a .vtk file and constructs a 3D model.'
    epilogue = '''
    '''
    parser = argparse.ArgumentParser(description=description, epilog=epilogue,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('filename', help='E.g. brain.vtk.')
    parser.add_argument('threshold', type=int, help='The threshold, e.g. 50.')
    parser.add_argument('-a', action='store_false', default=True, help='Extract all surfaces.')
    args = parser.parse_args()
    return args.filename, args.threshold, args.a

--
        ver = vtkVersion()
        vtk_version_number = 10000000000 * ver.GetVTKMajorVersion() + 100000000 * ver.GetVTKMinorVersion() \
                             + ver.GetVTKBuildVersion()
    if vtk_version_number >= needed_version:
        return True
    else:
--
    colors = vtkNamedColors()

    reader = vtkDataObjectReader()
    reader.SetFileName(ifn)

    size = 3187  # maximum number possible

    xAxis = 'INTEREST_RATE'
--
    do2ds = vtkDataObjectToDataSetFilter()
    do2ds.SetInputConnection(reader.GetOutputPort())
    do2ds.SetDataSetTypeToPolyData()
    # format: component#, arrayname, arraycomp, minArrayId, maxArrayId, normalize
    do2ds.DefaultNormalizeOn()
    do2ds.SetPointComponent(0, xAxis, 0)
--
    fd2ad = vtkFieldDataToAttributeDataFilter()
    fd2ad.SetInputConnection(do2ds.GetOutputPort())
    fd2ad.SetInputFieldToDataObjectField()
    fd2ad.SetOutputAttributeDataToPointData()
    fd2ad.DefaultNormalizeOn()
    fd2ad.SetScalarComponent(0, scalar, 0)
--
    popSplatter = vtkGaussianSplatter()
    popSplatter.SetInputConnection(fd2ad.GetOutputPort())
    popSplatter.SetSampleDimensions(150, 150, 150)
    popSplatter.SetRadius(0.05)
    popSplatter.ScalarWarpingOff()

    popSurface = vtkMarchingContourFilter()
    popSurface.SetInputConnection(popSplatter.GetOutputPort())
    popSurface.SetValue(0, 0.01)
    popMapper = vtkPolyDataMapper()
    popMapper.SetInputConnection(popSurface.GetOutputPort())
    popMapper.ScalarVisibilityOff()
    popActor = vtkActor()
    popActor.SetMapper(popMapper)
    popActor.GetProperty().SetOpacity(0.3)
    popActor.GetProperty().SetColor(colors.GetColor3d('Gold'))

    # Construct the pipeline for the delinquent population.
    lateSplatter = vtkGaussianSplatter()
    lateSplatter.SetInputConnection(fd2ad.GetOutputPort())
    lateSplatter.SetSampleDimensions(150, 150, 150)
    lateSplatter.SetRadius(0.05)
    lateSplatter.SetScaleFactor(0.05)

    lateSurface = vtkMarchingContourFilter()
    lateSurface.SetInputConnection(lateSplatter.GetOutputPort())
    lateSurface.SetValue(0, 0.01)
    lateMapper = vtkPolyDataMapper()
    lateMapper.SetInputConnection(lateSurface.GetOutputPort())
    lateMapper.ScalarVisibilityOff()
    lateActor = vtkActor()
    lateActor.SetMapper(lateMapper)
    lateActor.GetProperty().SetColor(colors.GetColor3d('Tomato'))

    # Create the axes.
    popSplatter.Update()
--
    axes = vtkAxes()
    axes.SetOrigin(bounds[0], bounds[2], bounds[4])
    axes.SetScaleFactor(popSplatter.GetOutput().GetLength() / 5.0)
    axesTubes = vtkTubeFilter()
    axesTubes.SetInputConnection(axes.GetOutputPort())
    axesTubes.SetRadius(axes.GetScaleFactor() / 25.0)
    axesTubes.SetNumberOfSides(6)
    axesMapper = vtkPolyDataMapper()
    axesMapper.SetInputConnection(axesTubes.GetOutputPort())
    axesActor = vtkActor()
    axesActor.SetMapper(axesMapper)

    # Label the axes.
    XText = vtkVectorText()
    XText.SetText(xAxis)
    XTextMapper = vtkPolyDataMapper()
    XTextMapper.SetInputConnection(XText.GetOutputPort())

    XActor = vtkFollower()
    XActor.SetMapper(XTextMapper)
    XActor.SetScale(0.02, .02, .02)
    XActor.SetPosition(0.35, -0.05, -0.05)
    XActor.GetProperty().SetColor(0, 0, 0)

    YText = vtkVectorText()
    YText.SetText(yAxis)

    YTextMapper = vtkPolyDataMapper()
    YTextMapper.SetInputConnection(YText.GetOutputPort())
    YActor = vtkFollower()
    YActor.SetMapper(YTextMapper)
    YActor.SetScale(0.02, .02, .02)
    YActor.SetPosition(-0.05, 0.35, -0.05)
    YActor.GetProperty().SetColor(0, 0, 0)

    ZText = vtkVectorText()
    ZText.SetText(zAxis)
    ZTextMapper = vtkPolyDataMapper()
    ZTextMapper.SetInputConnection(ZText.GetOutputPort())
    ZActor = vtkFollower()
    ZActor.SetMapper(ZTextMapper)
    ZActor.SetScale(0.02, .02, .02)
    ZActor.SetPosition(-0.05, -0.05, 0.35)
    ZActor.GetProperty().SetColor(0, 0, 0)

--
    renderer = vtkRenderer()
    renderWindow = vtkRenderWindow()
    renderWindow.AddRenderer(renderer)
    renderWindow.SetWindowName('FinanceFieldData')

    # Add the actors to the renderer, set the background and size.
    renderer.AddActor(axesActor)
--
    camera = vtkCamera()
    camera.SetClippingRange(.274, 13.72)
    camera.SetFocalPoint(0.433816, 0.333131, 0.449)
    camera.SetPosition(-1.96987, 1.15145, 1.49053)
    camera.SetViewUp(0.378927, 0.911821, 0.158107)
    renderer.SetActiveCamera(camera)
--
    interactor = vtkRenderWindowInteractor()
    interactor.SetRenderWindow(renderWindow)
    renderWindow.Render()
    interactor.Start()


--
    description = 'How to align two vtkPolyData\'s.'
    epilogue = '''

    '''
    parser = argparse.ArgumentParser(description=description, epilog=epilogue,
                                     formatter_class=argparse.RawTextHelpFormatter)
--
    colors = vtkNamedColors()

    src_fn, tgt_fn = get_program_parameters()
    print('Loading source:', src_fn)
    source_polydata = read_poly_data(src_fn)
    # Save the source polydata in case the alignment process does not improve
--
    original_source_polydata = vtkPolyData()
    original_source_polydata.DeepCopy(source_polydata)

    print('Loading target:', tgt_fn)
    target_polydata = read_poly_data(tgt_fn)

--
    trnf = vtkTransform()
    if Path(src_fn).name == 'Grey_Nurse_Shark.stl' and Path(tgt_fn).name == 'greatWhite.stl':
        trnf.RotateY(90)

    tpd = vtkTransformPolyDataFilter()
    tpd.SetTransform(trnf)
    tpd.SetInputData(target_polydata)
    tpd.Update()

    renderer = vtkRenderer()
    render_window = vtkRenderWindow()
    render_window.AddRenderer(renderer)
    interactor = vtkRenderWindowInteractor()
    interactor.SetRenderWindow(render_window)

    distance = vtkHausdorffDistancePointSetFilter()
    distance.SetInputData(0, tpd.GetOutput())
    distance.SetInputData(1, source_polydata)
    distance.Update()

    distance_before_align = distance.GetOutput(0).GetFieldData().GetArray('HausdorffDistance').GetComponent(0, 0)
--
    icp = vtkIterativeClosestPointTransform()
    icp.SetSource(source_polydata)
    icp.SetTarget(tpd.GetOutput())
    icp.GetLandmarkTransform().SetModeToRigidBody()
    icp.SetMaximumNumberOfLandmarks(100)
    icp.SetMaximumMeanDistance(.00001)
--
    transform = vtkTransformPolyDataFilter()
    transform.SetInputData(source_polydata)
    transform.SetTransform(lm_transform)
    transform.SetTransform(icp)
    transform.Update()

--
    source_mapper = vtkDataSetMapper()
    if best_distance == distance_before_align:
        source_mapper.SetInputData(original_source_polydata)
        print('Using original alignment')
    elif best_distance == distance_after_align:
        source_mapper.SetInputData(source_polydata)
--
    writer = vtkPolyDataWriter()
    if best_distance == distance_before_align:
        writer.SetInputData(original_source_polydata)
    elif best_distance == distance_after_align:
        writer.SetInputData(source_polydata)
    else:
--
    source_actor = vtkActor()
    source_actor.SetMapper(source_mapper)
    source_actor.GetProperty().SetOpacity(0.6)
    source_actor.GetProperty().SetDiffuseColor(
        colors.GetColor3d('White'))
    renderer.AddActor(source_actor)
--
    target_mapper = vtkDataSetMapper()
    target_mapper.SetInputData(tpd.GetOutput())
    target_mapper.ScalarVisibilityOff()

    target_actor = vtkActor()
    target_actor.SetMapper(target_mapper)
    target_actor.GetProperty().SetDiffuseColor(
        colors.GetColor3d('Tomato'))
    renderer.AddActor(target_actor)

--
            cam_orient_manipulator = vtkCameraOrientationWidget()
            cam_orient_manipulator.SetParentRenderer(renderer)
            # Enable the widget.
            cam_orient_manipulator.On()
        except AttributeError:
            pass
--
        axes = vtkAxesActor()
        widget = vtkOrientationMarkerWidget()
        rgba = [0.0, 0.0, 0.0, 0.0]
        colors.GetColor("Carrot", rgba)
        widget.SetOutlineColor(rgba[0], rgba[1], rgba[2])
        widget.SetOrientationMarker(axes)
        widget.SetInteractor(interactor)
--
        ver = vtkVersion()
        vtk_version_number = 10000000000 * ver.GetVTKMajorVersion() + 100000000 * ver.GetVTKMinorVersion() \
                             + ver.GetVTKBuildVersion()
    if vtk_version_number >= needed_version:
        return True
    else:
--
        reader = vtkPLYReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == ".vtp":
        reader = vtkXMLPolyDataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == ".obj":
        reader = vtkOBJReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == ".stl":
        reader = vtkSTLReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == ".vtk":
        reader = vtkPolyDataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == ".g":
        reader = vtkBYUReader()
        reader.SetGeometryFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    else:
        # Return a None if the extension is unknown.
--
    source_obb_tree = vtkOBBTree()
    source_obb_tree.SetDataSet(source)
    source_obb_tree.SetMaxLevel(1)
    source_obb_tree.BuildLocator()

    target_obb_tree = vtkOBBTree()
    target_obb_tree.SetDataSet(target)
    target_obb_tree.SetMaxLevel(1)
    target_obb_tree.BuildLocator()

    source_landmarks = vtkPolyData()
    source_obb_tree.GenerateRepresentation(0, source_landmarks)

    target_landmarks = vtkPolyData()
    target_obb_tree.GenerateRepresentation(0, target_landmarks)

    lm_transform = vtkLandmarkTransform()
    lm_transform.SetModeToSimilarity()
    lm_transform.SetTargetLandmarks(target_landmarks.GetPoints())
    best_distance = VTK_DOUBLE_MAX
    best_points = vtkPoints()
    best_distance = best_bounding_box(
        "X",
        target,
        source,
        target_landmarks,
--
    lm_transform_pd = vtkTransformPolyDataFilter()
    lm_transform_pd.SetInputData(source)
    lm_transform_pd.SetTransform(lm_transform)
    lm_transform_pd.Update()

    source.DeepCopy(lm_transform_pd.GetOutput())
--
    distance = vtkHausdorffDistancePointSetFilter()
    test_transform = vtkTransform()
    test_transform_pd = vtkTransformPolyDataFilter()
    lm_transform = vtkLandmarkTransform()
    lm_transform_pd = vtkTransformPolyDataFilter()

    lm_transform.SetModeToSimilarity()
    lm_transform.SetTargetLandmarks(target_landmarks.GetPoints())

    source_center = source_landmarks.GetCenter()
--
    description = 'How to align two vtkPolyData\'s.'
    epilogue = '''

    '''
    parser = argparse.ArgumentParser(description=description, epilog=epilogue,
                                     formatter_class=argparse.RawTextHelpFormatter)
--
    colors = vtkNamedColors()

    operation, fn1, fn2 = get_program_parameters()
    if fn1 and fn2:
        poly1 = ReadPolyData(fn1)
        tri1 = vtkTriangleFilter()
        tri1.SetInputData(poly1)
        clean1 = vtkCleanPolyData()
        clean1.SetInputConnection(tri1.GetOutputPort())
        clean1.Update()
        input1 = clean1.GetOutput()

        poly2 = ReadPolyData(fn2)
        tri2 = vtkTriangleFilter()
        tri2.SetInputData(poly2)
        tri2.Update()
        clean2 = vtkCleanPolyData()
        clean2.SetInputConnection(tri2.GetOutputPort())
        clean2.Update()
        input2 = clean2.GetOutput()
    else:
        sphereSource1 = vtkSphereSource()
        sphereSource1.SetCenter(0.25, 0, 0)
        sphereSource1.SetPhiResolution(21)
        sphereSource1.SetThetaResolution(21)
        sphereSource1.Update()
        input1 = sphereSource1.GetOutput()
--
        sphereSource2 = vtkSphereSource()
        sphereSource2.Update()
        input2 = sphereSource2.GetOutput()

    input1Mapper = vtkPolyDataMapper()
    input1Mapper.SetInputData(input1)
    input1Mapper.ScalarVisibilityOff()
    input1Actor = vtkActor()
    input1Actor.SetMapper(input1Mapper)
    input1Actor.GetProperty().SetDiffuseColor(colors.GetColor3d('Tomato'))
    input1Actor.GetProperty().SetSpecular(0.6)
    input1Actor.GetProperty().SetSpecularPower(20)
    input1Actor.SetPosition(input1.GetBounds()[1] - input1.GetBounds()[0], 0, 0)
--
    input2Mapper = vtkPolyDataMapper()
    input2Mapper.SetInputData(input2)
    input2Mapper.ScalarVisibilityOff()
    input2Actor = vtkActor()
    input2Actor.SetMapper(input2Mapper)
    input2Actor.GetProperty().SetDiffuseColor(colors.GetColor3d('Mint'))
    input2Actor.GetProperty().SetSpecular(0.6)
    input2Actor.GetProperty().SetSpecularPower(20)
    input2Actor.SetPosition(-(input1.GetBounds()[1] - input1.GetBounds()[0]), 0, 0)
--
    booleanOperation = vtkBooleanOperationPolyDataFilter()
    if operation.lower() == 'union':
        booleanOperation.SetOperationToUnion()
    elif operation.lower() == 'intersection':
        booleanOperation.SetOperationToIntersection()
    elif operation.lower() == 'difference':
--
    booleanOperationMapper = vtkPolyDataMapper()
    booleanOperationMapper.SetInputConnection(booleanOperation.GetOutputPort())
    booleanOperationMapper.ScalarVisibilityOff()

    booleanOperationActor = vtkActor()
    booleanOperationActor.SetMapper(booleanOperationMapper)
    booleanOperationActor.GetProperty().SetDiffuseColor(colors.GetColor3d('Banana'))
    booleanOperationActor.GetProperty().SetSpecular(0.6)
    booleanOperationActor.GetProperty().SetSpecularPower(20)

    renderer = vtkRenderer()
    renderer.AddViewProp(input1Actor)
    renderer.AddViewProp(input2Actor)
    renderer.AddViewProp(booleanOperationActor)
    renderer.SetBackground(colors.GetColor3d('Silver'))
    renderWindow = vtkRenderWindow()
    renderWindow.AddRenderer(renderer)
    renderWindow.SetSize(640, 480)
    renderWindow.SetWindowName('BooleanOperationPolyDataFilter')

    viewUp = [0.0, 0.0, 1.0]
--
    renWinInteractor = vtkRenderWindowInteractor()
    renWinInteractor.SetRenderWindow(renderWindow)

    renderWindow.Render()
    renWinInteractor.Start()

--
        reader = vtkPLYReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtp':
        reader = vtkXMLPolyDataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.obj':
        reader = vtkOBJReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.stl':
        reader = vtkSTLReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtk':
        reader = vtkPolyDataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.g':
        reader = vtkBYUReader()
        reader.SetGeometryFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    else:
        # Return a None if the extension is unknown.
--
        transform = vtkTransform()
        transform.Translate(center[0], center[1], center[2])
        transform.RotateY(90.0)
        transform.Translate(-center[0], -center[1], -center[2])
        transformPD = vtkTransformPolyDataFilter()
        transformPD.SetTransform(transform)
        transformPD.SetInputData(polyData1)
        transformPD.Update()
        polyData2 = transformPD.GetOutput()

--
    select = vtkSelectEnclosedPoints()
    select.SetInputData(polyData1)
    select.SetSurfaceData(polyData2)

    # Extract three meshes, one completely inside, one completely
    # outside and on the border between the inside and outside.
--
    threshold = vtkMultiThreshold()
    # Outside points have a 0 value in ALL points of a cell
    outsideId = threshold.AddBandpassIntervalSet(
        0, 0,
        vtkDataObject.FIELD_ASSOCIATION_POINTS, 'SelectedPoints',
        0, 1)
--
    colors = vtkNamedColors()
    outsideColor = colors.GetColor3d('Crimson')
    insideColor = colors.GetColor3d('Banana')
    borderColor = colors.GetColor3d('Mint')
    surfaceColor = colors.GetColor3d('Peacock')
    backgroundColor = colors.GetColor3d('Silver')
--
    outsideMapper = vtkDataSetMapper()
    outsideMapper.SetInputData(threshold.GetOutput().GetBlock(outsideId).GetBlock(0))
    outsideMapper.ScalarVisibilityOff()

    outsideActor = vtkActor()
    outsideActor.SetMapper(outsideMapper)
    outsideActor.GetProperty().SetDiffuseColor(outsideColor)
    outsideActor.GetProperty().SetSpecular(.6)
    outsideActor.GetProperty().SetSpecularPower(30)

--
    insideMapper = vtkDataSetMapper()
    insideMapper.SetInputData(threshold.GetOutput().GetBlock(insideId).GetBlock(0))
    insideMapper.ScalarVisibilityOff()

    insideActor = vtkActor()
    insideActor.SetMapper(insideMapper)
    insideActor.GetProperty().SetDiffuseColor(insideColor)
    insideActor.GetProperty().SetSpecular(.6)
    insideActor.GetProperty().SetSpecularPower(30)
    insideActor.GetProperty().EdgeVisibilityOn()
--
    borderMapper = vtkDataSetMapper()
    borderMapper.SetInputData(threshold.GetOutput().GetBlock(borderId).GetBlock(0))
    borderMapper.ScalarVisibilityOff()

    borderActor = vtkActor()
    borderActor.SetMapper(borderMapper)
    borderActor.GetProperty().SetDiffuseColor(borderColor)
    borderActor.GetProperty().SetSpecular(.6)
    borderActor.GetProperty().SetSpecularPower(30)
    borderActor.GetProperty().EdgeVisibilityOn()
--
    surfaceMapper = vtkDataSetMapper()
    surfaceMapper.SetInputData(polyData2)
    surfaceMapper.ScalarVisibilityOff()

    # Surface of object containing cell
    surfaceActor = vtkActor()
    surfaceActor.SetMapper(surfaceMapper)
    surfaceActor.GetProperty().SetDiffuseColor(surfaceColor)
    surfaceActor.GetProperty().SetOpacity(.1)

    renderer = vtkRenderer()
    renderWindow = vtkRenderWindow()
    renderWindow.AddRenderer(renderer)
    renderWindow.SetSize(640, 480)

    renderWindowInteractor = vtkRenderWindowInteractor()
    renderWindowInteractor.SetRenderWindow(renderWindow)

    renderer.SetBackground(backgroundColor)
    renderer.UseHiddenLineRemovalOn()

--
        reader = vtkPLYReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtp':
        reader = vtkXMLPolyDataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.obj':
        reader = vtkOBJReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.stl':
        reader = vtkSTLReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtk':
        reader = vtkPolyDataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.g':
        reader = vtkBYUReader()
        reader.SetGeometryFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    else:
        # Return a None if the extension is unknown.
--
    featureEdges = vtkFeatureEdges()
    featureEdges.FeatureEdgesOff()
    featureEdges.BoundaryEdgesOn()
    featureEdges.NonManifoldEdgesOn()
    featureEdges.SetInputData(polyData)
    featureEdges.Update()
--
        reader = vtkPLYReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtp':
        reader = vtkXMLPolyDataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.obj':
        reader = vtkOBJReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.stl':
        reader = vtkSTLReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtk':
        reader = vtkPolyDataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.g':
        reader = vtkBYUReader()
        reader.SetGeometryFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    else:
        # Return a None if the extension is unknown.
--
    gc = vtkCurvatures()
    gc.SetInputData(source)
    gc.SetCurvatureTypeToGaussian()
    gc.Update()
    if desired_surface in ['Bour', 'Enneper', 'Hills', 'RandomHills', 'Torus']:
        adjust_edge_curvatures(gc.GetOutput(), 'Gauss_Curvature')
--
    mc = vtkCurvatures()
    mc.SetInputData(source)
    mc.SetCurvatureTypeToMean()
    mc.Update()
    if desired_surface in ['Bour', 'Enneper', 'Hills', 'RandomHills', 'Torus']:
        adjust_edge_curvatures(mc.GetOutput(), 'Mean_Curvature')
--
    # writer = vtkXMLPolyDataWriter()
    # writer.SetFileName('Source.vtp')
    # writer.SetInputData(source)
    # writer.SetDataModeToBinary()
    # writer.Write()

--
    colors = vtkNamedColors()
    colors.SetColor("ParaViewBkg", [82, 87, 110, 255])

    window_width = 1024
    window_height = 512

    ren_win = vtkRenderWindow()
    ren_win.SetSize(window_width, window_height)
    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(ren_win)
    style = vtkInteractorStyleTrackballCamera()
    iren.SetInteractorStyle(style)

    # Create a common text property.
    text_property = vtkTextProperty()
    text_property.SetFontSize(24)
    text_property.SetJustificationToCentered()

    lut = get_diverging_lut()
    # lut = get_diverging_lut1()
--
        cam_orient_manipulator = vtkCameraOrientationWidget()
        has_cow = True

    curvature_types = ['Gauss_Curvature', 'Mean_Curvature']
    for idx, curvature_name in enumerate(curvature_types):

--
        mapper = vtkPolyDataMapper()
        mapper.SetInputData(source)
        mapper.SetScalarModeToUsePointFieldData()
        mapper.SelectColorArray(curvature_name)
        mapper.SetScalarRange(scalar_range)
        mapper.SetLookupTable(lut)
--
        actor = vtkActor()
        actor.SetMapper(mapper)

        # Create a scalar bar
        scalar_bar = vtkScalarBarActor()
        scalar_bar.SetLookupTable(mapper.GetLookupTable())
        scalar_bar.SetTitle(curvature_title)
        scalar_bar.UnconstrainedFontSizeOn()
        scalar_bar.SetNumberOfLabels(min(5, len(freq)))
        scalar_bar.SetMaximumWidthInPixels(window_width // 8)
--
        text_mapper = vtkTextMapper()
        text_mapper.SetInput(curvature_title)
        text_mapper.SetTextProperty(text_property)

        text_actor = vtkActor2D()
        text_actor.SetMapper(text_mapper)
        text_actor.SetPosition(250, 16)

        renderer = vtkRenderer()
        renderer.SetBackground(colors.GetColor3d('ParaViewBkg'))

        renderer.AddActor(actor)
        renderer.AddActor(text_actor)
        renderer.AddActor(scalar_bar)
--
    ver = vtkVersion()
    actual_version = (100 * ver.GetVTKMajorVersion() + ver.GetVTKMinorVersion()) \
                     * 100000000 + ver.GetVTKBuildVersion()
    if actual_version >= requested_version:
        return True
    else:
--
        cell_ids = vtkIdList()
        source.GetPointCells(pt_id, cell_ids)
        neighbour = set()
        for cell_idx in range(0, cell_ids.GetNumberOfIds()):
            cell_id = cell_ids.GetId(cell_idx)
            cell_point_ids = vtkIdList()
            source.GetCellPoints(cell_id, cell_point_ids)
            for cell_pt_idx in range(0, cell_point_ids.GetNumberOfIds()):
                neighbour.add(cell_point_ids.GetId(cell_pt_idx))
        return neighbour

--
    id_filter = vtkIdFilter()
    id_filter.SetInputData(source)
    id_filter.SetPointIds(True)
    id_filter.SetCellIds(False)
    id_filter.SetPointIdsArrayName(array_name)
    id_filter.SetCellIdsArrayName(array_name)
--
    edges = vtkFeatureEdges()
    edges.SetInputConnection(id_filter.GetOutputPort())
    edges.BoundaryEdgesOn()
    edges.ManifoldEdgesOff()
    edges.NonManifoldEdgesOff()
    edges.FeatureEdgesOff()
--
        curv = numpy_support.numpy_to_vtk(num_array=curvatures.ravel(),
                                          deep=True,
                                          array_type=VTK_DOUBLE)
        curv.SetName(curvature_name)
        source.GetPointData().RemoveArray(curvature_name)
        source.GetPointData().AddArray(curv)
--
    curv = numpy_support.numpy_to_vtk(num_array=curvatures.ravel(),
                                      deep=True,
                                      array_type=VTK_DOUBLE)
    curv.SetName(curvature_name)
    source.GetPointData().RemoveArray(curvature_name)
    source.GetPointData().AddArray(curv)
--
    ctf = vtkColorTransferFunction()
    ctf.SetColorSpaceToDiverging()
    # Cool to warm.
    ctf.AddRGBPoint(0.0, 0.230, 0.299, 0.754)
    ctf.AddRGBPoint(0.5, 0.865, 0.865, 0.865)
    ctf.AddRGBPoint(1.0, 0.706, 0.016, 0.150)
--
    lut = vtkLookupTable()
    lut.SetNumberOfTableValues(table_size)
    lut.Build()

    for i in range(0, table_size):
        rgba = list(ctf.GetColor(float(i) / table_size))
--
    colors = vtkNamedColors()
    # Colour transfer function.
    ctf = vtkColorTransferFunction()
    ctf.SetColorSpaceToDiverging()
    p1 = [0.0] + list(colors.GetColor3d('MidnightBlue'))
    p2 = [0.5] + list(colors.GetColor3d('Gainsboro'))
    p3 = [1.0] + list(colors.GetColor3d('DarkOrange'))
    ctf.AddRGBPoint(*p1)
--
    lut = vtkLookupTable()
    lut.SetNumberOfTableValues(table_size)
    lut.Build()

    for i in range(0, table_size):
        rgba = list(ctf.GetColor(float(i) / table_size))
--
    surface = vtkParametricBour()

    source = vtkParametricFunctionSource()
    source.SetUResolution(u_resolution)
    source.SetVResolution(v_resolution)
    source.GenerateTextureCoordinatesOn()
    source.SetParametricFunction(surface)
    source.Update()
--
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(source.GetOutputPort())
    tangents.Update()

    transform = vtkTransform()
    transform.RotateX(0.0)
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputConnection(tangents.GetOutputPort())
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    return transform_filter.GetOutput()
--
    surface = vtkCubeSource()

    # Triangulate.
    triangulation = vtkTriangleFilter()
    triangulation.SetInputConnection(surface.GetOutputPort())
    # Subdivide the triangles
    subdivide = vtkLinearSubdivisionFilter()
    subdivide.SetInputConnection(triangulation.GetOutputPort())
    subdivide.SetNumberOfSubdivisions(3)
    # Now the tangents.
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(subdivide.GetOutputPort())
    tangents.Update()
    return tangents.GetOutput()


--
    points = vtkPoints()
    for i in range(0, x_res):
        x = x_min + i * dx
        for j in range(0, y_res):
            y = y_min + j * dy
            points.InsertNextPoint(x, y, 0)
--
    plane = vtkPolyData()
    plane.SetPoints(points)

    # Triangulate the grid.
    delaunay = vtkDelaunay2D()
    delaunay.SetInputData(plane)
    delaunay.Update()

    polydata = delaunay.GetOutput()

    elevation = vtkDoubleArray()
    elevation.SetNumberOfTuples(points.GetNumberOfPoints())

    #  We define the parameters for the hills here.
    # [[0: x0, 1: y0, 2: x variance, 3: y variance, 4: amplitude]...]
    hd = [[-2.5, -2.5, 2.5, 6.5, 3.5], [2.5, 2.5, 2.5, 2.5, 2],
--
    textures = vtkFloatArray()
    textures.SetNumberOfComponents(2)
    textures.SetNumberOfTuples(2 * polydata.GetNumberOfPoints())
    textures.SetName("Textures")

    for i in range(0, x_res):
--
    normals = vtkPolyDataNormals()
    normals.SetInputData(polydata)
    normals.SetInputData(polydata)
    normals.SetFeatureAngle(30)
    normals.SplittingOff()

    tr1 = vtkTransform()
    tr1.RotateX(-90)

    tf1 = vtkTransformPolyDataFilter()
    tf1.SetInputConnection(normals.GetOutputPort())
    tf1.SetTransform(tr1)
    tf1.Update()

    return tf1.GetOutput()
--
    surface = vtkParametricEnneper()

    source = vtkParametricFunctionSource()
    source.SetUResolution(u_resolution)
    source.SetVResolution(v_resolution)
    source.GenerateTextureCoordinatesOn()
    source.SetParametricFunction(surface)
    source.Update()
--
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(source.GetOutputPort())
    tangents.Update()

    transform = vtkTransform()
    transform.RotateX(0.0)
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputConnection(tangents.GetOutputPort())
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    return transform_filter.GetOutput()
--
    surface = vtkParametricMobius()
    surface.SetMinimumV(-0.25)
    surface.SetMaximumV(0.25)

    source = vtkParametricFunctionSource()
    source.SetUResolution(u_resolution)
    source.SetVResolution(v_resolution)
    source.GenerateTextureCoordinatesOn()
    source.SetParametricFunction(surface)
    source.Update()
--
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(source.GetOutputPort())
    tangents.Update()

    transform = vtkTransform()
    transform.RotateX(-90.0)
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputConnection(tangents.GetOutputPort())
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    return transform_filter.GetOutput()
--
    surface = vtkParametricRandomHills()
    surface.SetRandomSeed(1)
    surface.SetNumberOfHills(30)
    # If you want a plane
    # surface.SetHillAmplitude(0)

    source = vtkParametricFunctionSource()
    source.SetUResolution(u_resolution)
    source.SetVResolution(v_resolution)
    source.GenerateTextureCoordinatesOn()
    source.SetParametricFunction(surface)
    source.Update()
--
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(source.GetOutputPort())
    tangents.Update()

    transform = vtkTransform()
    transform.Translate(0.0, 5.0, 15.0)
    transform.RotateX(-90.0)
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputConnection(tangents.GetOutputPort())
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    return transform_filter.GetOutput()
--
    surface = vtkTexturedSphereSource()
    surface.SetThetaResolution(theta_resolution)
    surface.SetPhiResolution(phi_resolution)

    # Now the tangents.
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(surface.GetOutputPort())
    tangents.Update()

    return tangents.GetOutput()

--
    surface = vtkParametricTorus()

    source = vtkParametricFunctionSource()
    source.SetUResolution(u_resolution)
    source.SetVResolution(v_resolution)
    source.GenerateTextureCoordinatesOn()
    source.SetParametricFunction(surface)
    source.Update()
--
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(source.GetOutputPort())
    tangents.Update()

    transform = vtkTransform()
    transform.RotateX(-90.0)
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputConnection(tangents.GetOutputPort())
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    return transform_filter.GetOutput()
--
    colors = vtkNamedColors()

    # We are going to handle two different sources.
    # The first source is a superquadric source.
    torus = vtkSuperquadricSource()
    torus.SetCenter(0.0, 0.0, 0.0)
    torus.SetScale(1.0, 1.0, 1.0)
    torus.SetPhiResolution(64)
    torus.SetThetaResolution(64)
    torus.SetThetaRoundness(1)
--
    toroid_transform = vtkTransform()
    toroid_transform.RotateX(55)

    toroid_transform_filter = vtkTransformFilter()
    toroid_transform_filter.SetInputConnection(torus.GetOutputPort())
    toroid_transform_filter.SetTransform(toroid_transform)

    # The quadric is made of strips, so pass it through a triangle filter as
    # the curvature filter only operates on polys
    tri = vtkTriangleFilter()
    tri.SetInputConnection(toroid_transform_filter.GetOutputPort())

    # The quadric has nasty discontinuities from the way the edges are generated
    # so let's pass it though a CleanPolyDataFilter and merge any points which
    # are coincident, or very close
--
    cleaner = vtkCleanPolyData()
    cleaner.SetInputConnection(tri.GetOutputPort())
    cleaner.SetTolerance(0.005)
    cleaner.Update()

    # The next source will be a parametric function
    rh = vtkParametricRandomHills()
    rh_fn_src = vtkParametricFunctionSource()
    rh_fn_src.SetParametricFunction(rh)
    rh_fn_src.Update()

    sources = list()
    for i in range(0, 4):
        cc = vtkCurvatures()
        if i < 2:
            cc.SetInputConnection(cleaner.GetOutputPort())
        else:
            cc.SetInputConnection(rh_fn_src.GetOutputPort())
        if i % 2 == 0:
--
    text_property = vtkTextProperty()
    text_property.SetFontSize(24)
    text_property.SetJustificationToCentered()

    # RenderWindow Dimensions
    #
--
    render_window = vtkRenderWindow()
    render_window.SetSize(renderer_size * grid_dimensions, renderer_size * grid_dimensions)
    render_window.SetWindowName('CurvaturesDemo')

    # Add and position the renders to the render window.
    viewport = list()
--
    interactor = vtkRenderWindowInteractor()
    interactor.SetRenderWindow(render_window)
    style = vtkInteractorStyleTrackballCamera()
    interactor.SetInteractorStyle(style)

    render_window.Render()

    interactor.Start()
--
    ctf = vtkColorTransferFunction()
    ctf.SetColorSpaceToDiverging()
    # Cool to warm.
    ctf.AddRGBPoint(0.0, 0.230, 0.299, 0.754)
    ctf.AddRGBPoint(0.5, 0.865, 0.865, 0.865)
    ctf.AddRGBPoint(1.0, 0.706, 0.016, 0.150)
--
    lut = vtkLookupTable()
    lut.SetNumberOfTableValues(table_size)
    lut.Build()

    for i in range(0, table_size):
        rgba = list(ctf.GetColor(float(i) / table_size))
--
    colors = vtkNamedColors()
    # Colour transfer function.
    ctf = vtkColorTransferFunction()
    ctf.SetColorSpaceToDiverging()
    p1 = [0.0] + list(colors.GetColor3d('MidnightBlue'))
    p2 = [0.5] + list(colors.GetColor3d('Gainsboro'))
    p3 = [1.0] + list(colors.GetColor3d('DarkOrange'))
    ctf.AddRGBPoint(*p1)
--
    lut = vtkLookupTable()
    lut.SetNumberOfTableValues(table_size)
    lut.Build()

    for i in range(0, table_size):
        rgba = list(ctf.GetColor(float(i) / table_size))
--
    ver = vtkVersion()
    actual_version = (100 * ver.GetVTKMajorVersion() + ver.GetVTKMinorVersion()) \
                     * 100000000 + ver.GetVTKBuildVersion()
    if actual_version >= requested_version:
        return True
    else:
--
        cell_ids = vtkIdList()
        source.GetPointCells(pt_id, cell_ids)
        neighbour = set()
        for cell_idx in range(0, cell_ids.GetNumberOfIds()):
            cell_id = cell_ids.GetId(cell_idx)
            cell_point_ids = vtkIdList()
            source.GetCellPoints(cell_id, cell_point_ids)
            for cell_pt_idx in range(0, cell_point_ids.GetNumberOfIds()):
                neighbour.add(cell_point_ids.GetId(cell_pt_idx))
        return neighbour

--
    id_filter = vtkIdFilter()
    id_filter.SetInputData(source)
    id_filter.SetPointIds(True)
    id_filter.SetCellIds(False)
    id_filter.SetPointIdsArrayName(array_name)
    id_filter.SetCellIdsArrayName(array_name)
--
    edges = vtkFeatureEdges()
    edges.SetInputConnection(id_filter.GetOutputPort())
    edges.BoundaryEdgesOn()
    edges.ManifoldEdgesOff()
    edges.NonManifoldEdgesOff()
    edges.FeatureEdgesOff()
--
        curv = numpy_support.numpy_to_vtk(num_array=curvatures.ravel(),
                                          deep=True,
                                          array_type=VTK_DOUBLE)
        curv.SetName(curvature_name)
        source.GetPointData().RemoveArray(curvature_name)
        source.GetPointData().AddArray(curv)
--
    reader = vtkXMLPolyDataReader()
    reader.SetFileName(file_name)
    reader.Update()

    source = reader.GetOutput()

    cc = vtkCurvatures()
    cc.SetInputData(source)
    if gaussian_curvature:
        cc.SetCurvatureTypeToGaussian()
        cc.Update()
    else:
--
    # writer = vtkXMLPolyDataWriter()
    # writer.SetFileName('Source.vtp')
    # writer.SetInputData(source)
    # writer.SetDataModeToAscii()
    # writer.Write()

--
    color_series = vtkColorSeries()
    color_series.SetColorScheme(color_map_idx)
    print(f'Using color scheme #: {color_series.GetColorScheme()}, {color_series.GetColorSchemeName()}')

    lut = vtkColorTransferFunction()
    lut.SetColorSpaceToHSV()

    # Use a color series to create a transfer function
    for i in range(0, color_series.GetNumberOfColors()):
        color = color_series.GetColor(i)
--
    colors = vtkNamedColors()

    # Create a mapper and actor.
    mapper = vtkPolyDataMapper()
    mapper.SetInputData(source)
    mapper.SetScalarModeToUsePointFieldData()
    mapper.SelectColorArray(curvature)
    mapper.SetScalarRange(scalar_range)
    mapper.SetLookupTable(lut)
--
    actor = vtkActor()
    actor.SetMapper(mapper)

    window_width = 800
    window_height = 800

--
    scalar_bar = vtkScalarBarActor()
    scalar_bar.SetLookupTable(mapper.GetLookupTable())
    scalar_bar.SetTitle(curvature.replace('_', '\n'))
    scalar_bar.UnconstrainedFontSizeOn()
    scalar_bar.SetNumberOfLabels(5)
    scalar_bar.SetMaximumWidthInPixels(window_width // 8)
--
    renderer = vtkRenderer()
    ren_win = vtkRenderWindow()
    ren_win.AddRenderer(renderer)
    ren_win.SetSize(window_width, window_height)
    ren_win.SetWindowName('Curvatures')

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(ren_win)
    # Important: The interactor must be set prior to enabling the widget.
    iren.SetRenderWindow(ren_win)

    if vtk_version_ok(9, 0, 20210718):
        cam_orient_manipulator = vtkCameraOrientationWidget()
        cam_orient_manipulator.SetParentRenderer(renderer)
        # Enable the widget.
        cam_orient_manipulator.On()

    # Add the actors to the scene
--
    ver = vtkVersion()
    actual_version = (100 * ver.GetVTKMajorVersion() + ver.GetVTKMinorVersion()) \
                     * 100000000 + ver.GetVTKBuildVersion()
    if actual_version >= requested_version:
        return True
    else:
--
        cell_ids = vtkIdList()
        source.GetPointCells(pt_id, cell_ids)
        neighbour = set()
        for cell_idx in range(0, cell_ids.GetNumberOfIds()):
            cell_id = cell_ids.GetId(cell_idx)
            cell_point_ids = vtkIdList()
            source.GetCellPoints(cell_id, cell_point_ids)
            for cell_pt_idx in range(0, cell_point_ids.GetNumberOfIds()):
                neighbour.add(cell_point_ids.GetId(cell_pt_idx))
        return neighbour

--
    id_filter = vtkIdFilter()
    id_filter.SetInputData(source)
    id_filter.SetPointIds(True)
    id_filter.SetCellIds(False)
    id_filter.SetPointIdsArrayName(array_name)
    id_filter.SetCellIdsArrayName(array_name)
--
    edges = vtkFeatureEdges()
    edges.SetInputConnection(id_filter.GetOutputPort())
    edges.BoundaryEdgesOn()
    edges.ManifoldEdgesOff()
    edges.NonManifoldEdgesOff()
    edges.FeatureEdgesOff()
--
        curv = numpy_support.numpy_to_vtk(num_array=curvatures.ravel(),
                                          deep=True,
                                          array_type=VTK_DOUBLE)
        curv.SetName(curvature_name)
        source.GetPointData().RemoveArray(curvature_name)
        source.GetPointData().AddArray(curv)
--
sphere = vtk.vtkSphereSource()
sphere.SetCenter(1, 1, 1)
sphere.SetRadius(1)
sphere.Update()

cube = vtk.vtkCubeSource()
cube.SetBounds(-1, 1, -1, 1, -1, 1)
cube.Update()

# Create 3D cells so vtkImplicitDataSet evaluates inside vs outside correctly
tri = vtk.vtkDelaunay3D()
tri.SetInputConnection(cube.GetOutputPort())
tri.BoundingTriangulationOff()

# vtkImplicitDataSet needs some scalars to interpolate to find inside/outside
elev = vtk.vtkElevationFilter()
elev.SetInputConnection(tri.GetOutputPort())

implicit = vtk.vtkImplicitDataSet()
implicit.SetDataSet(elev.GetOutput())

clipper = vtk.vtkClipPolyData()
clipper.SetClipFunction(implicit)
clipper.SetInputConnection(sphere.GetOutputPort())
clipper.InsideOutOn()
clipper.Update()

--
mapper = vtk.vtkPolyDataMapper()
mapper.SetInputConnection(clipper.GetOutputPort())
actor = vtk.vtkActor()
actor.SetMapper(mapper)

# Vis for cube so can see it in relation to clipped sphere
mapper2 = vtk.vtkDataSetMapper()
mapper2.SetInputConnection(elev.GetOutputPort())
actor2 = vtk.vtkActor()
actor2.SetMapper(mapper2)
actor2.GetProperty().SetRepresentationToWireframe()

ren1 = vtk.vtkRenderer()
ren1.AddActor(actor)
ren1.AddActor(actor2)
ren1.SetBackground(0.1, 0.2, 0.4)

renWin = vtk.vtkRenderWindow()
renWin.AddRenderer(ren1)

iren = vtk.vtkRenderWindowInteractor()
iren.SetRenderWindow(renWin)

renWin.Render()
iren.Start()
--
tse = vtk.vtkTimeSourceExample()
ex = tse.GetExecutive()
tse.UpdateInformation()

# inspect available time range and time steps
print(ex.GetOutputInformation())
--
tri = vtk.vtkDataSetTriangleFilter()
tri.SetInputData(grid)
tri.SetTetrahedraOnly(1)
tri.Update()
output = tri.GetOutput()

--
opacityFunction = vtk.vtkPiecewiseFunction()
opacityFunction.AddPoint(drange[0], 0.0)
opacityFunction.AddPoint(drange[1], 1.0)

# Create transfer mapping scalar value to color.
colorFunction = vtk.vtkColorTransferFunction()
colorFunction.SetColorSpaceToHSV()
colorFunction.HSVWrapOff()
colorFunction.AddRGBPoint(drange[0], 0.0, 0.0, 1.0)
colorFunction.AddRGBPoint(drange[1], 1.0, 0.0, 0.0)

volumeProperty = vtk.vtkVolumeProperty()
volumeProperty.SetScalarOpacity(opacityFunction)
volumeProperty.SetColor(colorFunction)
volumeProperty.ShadeOff()
volumeProperty.SetInterpolationTypeToLinear()
# volumeProperty.SetScalarOpacityUnitDistance(options.unit)
--
volumeMapper = vtk.vtkUnstructuredGridVolumeRayCastMapper()
# volumeMapper = vtk.vtkUnstructuredGridVolumeZSweepMapper()
# volumeMapper = vtk.vtkProjectedTetrahedraMapper()
# volumeMapper.SetBlendModeToMaximumIntensity()
volumeMapper.SetInputData(output)

volume = vtk.vtkVolume()
volume.SetMapper(volumeMapper)
volume.SetProperty(volumeProperty)

# create a rendering window and renderer
renderer = vtk.vtkRenderer()
renderer.SetBackground(0, 0, 0)

window = vtk.vtkRenderWindow()
window.SetSize(512, 512)
window.AddRenderer(renderer)

interactor = vtk.vtkRenderWindowInteractor()
interactor.SetRenderWindow(window)

style = vtk.vtkInteractorStyleTrackballCamera()
interactor.SetInteractorStyle(style)

renderer.AddVolume(volume)

scalarBar = vtk.vtkScalarBarActor()
scalarBar.SetLookupTable(colorFunction)
scalarBar.SetOrientationToVertical()
scalarBar.SetPosition(0.85, 0.7)
scalarBar.SetPosition2(0.1, 0.3)
propT = vtk.vtkTextProperty()
propL = vtk.vtkTextProperty()
propT.SetFontFamilyToArial()
propT.ItalicOff()
propT.BoldOn()
propL.BoldOff()
scalarBar.SetTitleTextProperty(propT)
--
textActor = vtk.vtkTextActor()
textActor.GetTextProperty().SetFontSize(12)
textActor.SetPosition2(10, 40)
renderer.AddActor2D(textActor)
textActor.SetInput("time = ")
textActor.GetTextProperty().SetColor(1.0, 1.0, 1.0)
--
    volume = vtk.vtkVolume()
    volume.SetMapper(volumeMapper)
    volume.SetProperty(volumeProperty)
    renderer.AddVolume(volume)

    counter = counter + 1
--
    ren_win = vtkRenderWindow()
    ren_win.SetWindowName('GradientBackground')

    iren = vtkRenderWindowInteractor()
    renderers = []

    # For each gradient specify the mode.
    modes = [
        vtkViewport.GradientModes.VTK_GRADIENT_VERTICAL,
--
    colors = vtkNamedColors()

    mapper = vtkPolyDataMapper()
    mapper.SetInputData(pd)

    actor = vtkActor()
    actor.SetMapper(mapper)
    actor.GetProperty().SetColor(colors.GetColor3d('Honeydew'))
    actor.GetProperty().SetSpecular(0.3)
    actor.GetProperty().SetSpecularPower(60.0)

--
    text_property = vtkTextProperty()
    text_property.SetJustificationToCentered()
    text_property.SetFontSize(ren_height // 12)
    text_property.SetColor(colors.GetColor3d('MidnightBlue'))

    text_mappers = []
--
    style = vtkInteractorStyleTrackballCamera()
    iren.SetInteractorStyle(style)

    iren.Initialize()
    iren.UpdateSize(ren_width * 2, ren_height * 2)

--
    poly_data = vtkPolyData()

    if path is None:
        # Default to a cone if the path is empty.
        source = vtkConeSource()
        source.SetResolution(25)
        source.SetDirection(0, 1, 0)
        source.SetHeight(1)
        source.Update()
        poly_data.DeepCopy(source.GetOutput())
--
    valid_suffixes = ['.g', '.obj', '.stl', '.ply', '.vtk', '.vtp']
    ext = path.suffix.lower()
    if path.suffix not in valid_suffixes:
        print('Warning:', path, 'unknown extension, using a sphere instead.')
        source = vtkSphereSource()
        source.SetPhiResolution(50)
        source.SetThetaResolution(50)
        source.Update()
        poly_data.DeepCopy(source.GetOutput())
    else:
--
            reader = vtkPLYReader()
            reader.SetFileName(file_name)
            reader.Update()
            poly_data.DeepCopy(reader.GetOutput())
        elif ext == '.vtp':
            reader = vtkXMLPolyDataReader()
            reader.SetFileName(file_name)
            reader.Update()
            poly_data.DeepCopy(reader.GetOutput())
        elif ext == '.obj':
            reader = vtkOBJReader()
            reader.SetFileName(file_name)
            reader.Update()
            poly_data.DeepCopy(reader.GetOutput())
        elif ext == '.stl':
            reader = vtkSTLReader()
            reader.SetFileName(file_name)
            reader.Update()
            poly_data.DeepCopy(reader.GetOutput())
        elif ext == '.vtk':
            reader = vtkPolyDataReader()
            reader.SetFileName(file_name)
            reader.Update()
            poly_data.DeepCopy(reader.GetOutput())
        elif ext == '.g':
            reader = vtkBYUReader()
            reader.SetGeometryFileName(file_name)
            reader.Update()
            poly_data.DeepCopy(reader.GetOutput())

    return poly_data
--
    colors = vtkNamedColors()

    # Points start at upper right and proceed anti-clockwise.
    points = vtkPoints()
    points.SetNumberOfPoints(4)
    points.InsertPoint(0, 1, 1, 0)
    points.InsertPoint(1, 0, 1, 0)
    points.InsertPoint(2, 0, 0, 0)
    points.InsertPoint(3, 1, 0, 0)
--
    cells = vtkCellArray()
    cells.Initialize()

    if sides[0]:
        # Top
        top = vtkPolyLine()
        top.GetPointIds().SetNumberOfIds(2)
        top.GetPointIds().SetId(0, 0)
        top.GetPointIds().SetId(1, 1)
        cells.InsertNextCell(top)
    if sides[1]:
--
        left = vtkPolyLine()
        left.GetPointIds().SetNumberOfIds(2)
        left.GetPointIds().SetId(0, 1)
        left.GetPointIds().SetId(1, 2)
        cells.InsertNextCell(left)
    if sides[2]:
--
        bottom = vtkPolyLine()
        bottom.GetPointIds().SetNumberOfIds(2)
        bottom.GetPointIds().SetId(0, 2)
        bottom.GetPointIds().SetId(1, 3)
        cells.InsertNextCell(bottom)
    if sides[3]:
--
        right = vtkPolyLine()
        right.GetPointIds().SetNumberOfIds(2)
        right.GetPointIds().SetId(0, 3)
        right.GetPointIds().SetId(1, 0)
        cells.InsertNextCell(right)

--
    poly = vtkPolyData()
    poly.Initialize()
    poly.SetPoints(points)
    poly.SetLines(cells)

    # Use normalized viewport coordinates since
--
    coordinate = vtkCoordinate()
    coordinate.SetCoordinateSystemToNormalizedViewport()

    mapper = vtkPolyDataMapper2D()
    mapper.SetInputData(poly)
    mapper.SetTransformCoordinate(coordinate)

    actor = vtkActor2D()
    actor.SetMapper(mapper)
    actor.GetProperty().SetColor(colors.GetColor3d(border_color))

    # Line width should be at least 2 to be visible at extremes.
    actor.GetProperty().SetLineWidth(border_width)
--
    colors = vtkNamedColors()
    colors.SetColor('Brass', [184, 115, 51, 255])

    ren = vtkOpenGLRenderer()
    ren.SetBackground(colors.GetColor3d('Black'))

    ren_win = vtkRenderWindow()
    ren_win.SetSize(600, 600)
    ren_win.AddRenderer(ren)

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(ren_win)

    style = vtkInteractorStyleTrackballCamera()
    iren.SetInteractorStyle(style)

    skybox = vtkOpenGLSkybox()

    irradiance = ren.GetEnvMapIrradiance()
    irradiance.SetIrradianceStep(0.3)

    # Choose how to generate the skybox.
--
    sphere = vtkSphereSource()
    sphere.SetThetaResolution(75)
    sphere.SetPhiResolution(75)

    pd_sphere = vtkPolyDataMapper()
    pd_sphere.SetInputConnection(sphere.GetOutputPort())

    texture_map = vtkTextureMapToSphere()
    texture_map.SetInputConnection(sphere.GetOutputPort())
    texture_map.PreventSeamOff()

    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(texture_map.GetOutputPort())

    mapper = vtkPolyDataMapper()
    mapper.SetInputConnection(tangents.GetOutputPort())

    for i in range(0, 6):
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 0.0, 0.0)
        actor_sphere.RotateX(20)
        actor_sphere.RotateY(20)
        actor_sphere.SetMapper(mapper)
        actor_sphere.GetProperty().SetInterpolationToPBR()
--
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 1.0, 0.0)
        actor_sphere.RotateX(20)
        actor_sphere.RotateY(20)
        actor_sphere.SetMapper(mapper)
        actor_sphere.GetProperty().SetInterpolationToPBR()
--
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 2.0, 0.0)
        actor_sphere.RotateX(20)
        actor_sphere.RotateY(20)
        actor_sphere.SetMapper(mapper)
        actor_sphere.GetProperty().SetInterpolationToPBR()
--
    cube_map = vtkTexture()
    cube_map.CubeMapOn()

    i = 0
    for fn in cubemap:
        # Read the images.
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn))
        img_reader.SetFileName(str(fn))

        # Each image must be flipped in Y due to canvas
        #  versus vtk ordering.
        flip = vtkImageFlip()
        flip.SetInputConnection(img_reader.GetOutputPort(0))
        flip.SetFilteredAxis(1)  # flip y axis
        cube_map.SetInputConnection(i, flip.GetOutputPort())
        i += 1

--
    texture = vtkTexture()

    suffix = fn_path.suffix.lower()
    if suffix in ['.jpeg', '.jpg', '.png']:
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn_path))
        img_reader.SetFileName(str(fn_path))

        texture.SetInputConnection(img_reader.GetOutputPort(0))

--
        reader = vtkHDRReader()
        extensions = reader.GetFileExtensions()
        # Check the image can be read.
        if not reader.CanReadFile(str(fn_path)):
            print('CanReadFile failed for ', fn_path)
            return None
--
    colors = vtkNamedColors()

    ren = vtkOpenGLRenderer()
    ren.SetBackground(colors.GetColor3d('Black'))
    ren.AutomaticLightCreationOff()

    light = vtkLight()
    light.SetPosition(2.0, 0.0, 2.0)
    light.SetFocalPoint(0.0, 0.0, 0.0)

    ren.AddLight(light)

    ren_win = vtkRenderWindow()
    ren_win.SetSize(600, 600)
    ren_win.AddRenderer(ren)

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(ren_win)

    style = vtkInteractorStyleTrackballCamera()
    iren.SetInteractorStyle(style)

    skybox = vtkSkybox()

    irradiance = ren.GetEnvMapIrradiance()
    irradiance.SetIrradianceStep(0.3)

    # Choose how to generate the skybox.
--
    cube = vtkCubeSource()

    triangulation = vtkTriangleFilter()
    triangulation.SetInputConnection(cube.GetOutputPort())

    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(triangulation.GetOutputPort())

    mapper = vtkPolyDataMapper()
    mapper.SetInputConnection(tangents.GetOutputPort())

    material_reader = vtkPNGReader()
    material_reader.SetFileName(parameters['material'])

    material = vtkTexture()
    material.InterpolateOn()
    material.SetInputConnection(material_reader.GetOutputPort())

    albedo_reader = vtkPNGReader()
    albedo_reader.SetFileName(parameters['albedo'])

    albedo = vtkTexture()
    albedo.UseSRGBColorSpaceOn()
    albedo.InterpolateOn()
    albedo.SetInputConnection(albedo_reader.GetOutputPort())

    normal_reader = vtkPNGReader()
    normal_reader.SetFileName(parameters['normal'])

    # Uncomment this if you want a similar image to the VTK test image.
    # flip = vtkImageFlip()
    # flip.SetInputConnection(normal_reader.GetOutputPort())
    # flip.SetFilteredAxes(0)

    normal = vtkTexture()
    normal.InterpolateOn()
    normal.SetInputConnection(normal_reader.GetOutputPort())

    coat_normal = vtkTexture()
    coat_normal.InterpolateOn()
    coat_normal.SetInputConnection(normal_reader.GetOutputPort())
    # Uncomment this if you want a similar image to the VTK test image.
    # coat_normal.SetInputConnection(flip.GetOutputPort())

    actor = vtkActor()
    actor.SetOrientation(0.0, 25.0, 0.0)
    actor.SetMapper(mapper)
    actor.GetProperty().SetInterpolationToPBR()

    # Set metallic, roughness and coat strength to 1.0 as they act as multipliers
--
    cube_map = vtkTexture()
    cube_map.CubeMapOn()

    i = 0
    for fn in cubemap:
        # Read the images.
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn))
        img_reader.SetFileName(str(fn))

        # Each image must be flipped in Y due to canvas
        #  versus vtk ordering.
        flip = vtkImageFlip()
        flip.SetInputConnection(img_reader.GetOutputPort(0))
        flip.SetFilteredAxis(1)  # flip y axis
        cube_map.SetInputConnection(i, flip.GetOutputPort())
        i += 1

--
    texture = vtkTexture()

    suffix = fn_path.suffix.lower()
    if suffix in ['.jpeg', '.jpg', '.png']:
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn_path))
        img_reader.SetFileName(str(fn_path))

        texture.SetInputConnection(img_reader.GetOutputPort(0))

--
        reader = vtkHDRReader()
        extensions = reader.GetFileExtensions()
        # Check the image can be read.
        if not reader.CanReadFile(str(fn_path)):
            print('CanReadFile failed for ', fn_path)
            return None
--
    colors = vtkNamedColors()

    ren = vtkOpenGLRenderer()
    ren.SetBackground(colors.GetColor3d('Black'))

    ren_win = vtkRenderWindow()
    ren_win.SetSize(600, 600)
    ren_win.AddRenderer(ren)

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(ren_win)

    style = vtkInteractorStyleTrackballCamera()
    iren.SetInteractorStyle(style)

    skybox = vtkSkybox()

    irradiance = ren.GetEnvMapIrradiance()
    irradiance.SetIrradianceStep(0.3)

    # Choose how to generate the skybox.
--
    sphere = vtkSphereSource()
    sphere.SetThetaResolution(75)
    sphere.SetPhiResolution(75)

    pd_sphere = vtkPolyDataMapper()
    pd_sphere.SetInputConnection(sphere.GetOutputPort())

    for i in range(0, 6):
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 0.0, 0.0)
        actor_sphere.SetMapper(pd_sphere)
        actor_sphere.GetProperty().SetInterpolationToPBR()
        actor_sphere.GetProperty().SetColor(colors.GetColor3d('White'))
        actor_sphere.GetProperty().SetMetallic(1.0)
--
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 1.0, 0.0)
        actor_sphere.SetMapper(pd_sphere)
        actor_sphere.GetProperty().SetInterpolationToPBR()
        actor_sphere.GetProperty().SetColor(colors.GetColor3d('Black'))
        actor_sphere.GetProperty().SetMetallic(1.0)
--
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 2.0, 0.0)
        actor_sphere.SetMapper(pd_sphere)
        actor_sphere.GetProperty().SetInterpolationToPBR()
        actor_sphere.GetProperty().SetColor(colors.GetColor3d('Blue'))
        actor_sphere.GetProperty().SetMetallic(1.0)
--
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 3.0, 0.0)
        actor_sphere.SetMapper(pd_sphere)
        actor_sphere.GetProperty().SetInterpolationToPBR()
        actor_sphere.GetProperty().SetColor(colors.GetColor3d('Red'))
        actor_sphere.GetProperty().SetMetallic(1.0)
--
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 4.0, 0.0)
        actor_sphere.SetMapper(pd_sphere)
        actor_sphere.GetProperty().SetInterpolationToPBR()
        actor_sphere.GetProperty().SetColor(colors.GetColor3d('Black'))
        actor_sphere.GetProperty().SetMetallic(1.0)
--
    cube_map = vtkTexture()
    cube_map.CubeMapOn()

    i = 0
    for fn in cubemap:
        # Read the images.
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn))
        img_reader.SetFileName(str(fn))

        # Each image must be flipped in Y due to canvas
        #  versus vtk ordering.
        flip = vtkImageFlip()
        flip.SetInputConnection(img_reader.GetOutputPort(0))
        flip.SetFilteredAxis(1)  # flip y axis
        cube_map.SetInputConnection(i, flip.GetOutputPort())
        i += 1

--
    texture = vtkTexture()

    suffix = fn_path.suffix.lower()
    if suffix in ['.jpeg', '.jpg', '.png']:
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn_path))
        img_reader.SetFileName(str(fn_path))

        texture.SetInputConnection(img_reader.GetOutputPort(0))

--
        reader = vtkHDRReader()
        extensions = reader.GetFileExtensions()
        # Check the image can be read.
        if not reader.CanReadFile(str(fn_path)):
            print('CanReadFile failed for ', fn_path)
            return None
--
    colors = vtkNamedColors()

    ren = vtkOpenGLRenderer()
    ren.SetBackground(colors.GetColor3d('Black'))

    ren_win = vtkRenderWindow()
    ren_win.SetSize(600, 600)
    ren_win.AddRenderer(ren)

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(ren_win)

    style = vtkInteractorStyleTrackballCamera()
    iren.SetInteractorStyle(style)

    skybox = vtkSkybox()

    irradiance = ren.GetEnvMapIrradiance()
    irradiance.SetIrradianceStep(0.3)

    # Choose how to generate the skybox.
--
    sphere = vtkSphereSource()
    sphere.SetThetaResolution(75)
    sphere.SetPhiResolution(75)

    pd_sphere = vtkPolyDataMapper()
    pd_sphere.SetInputConnection(sphere.GetOutputPort())

    for i in range(0, 6):
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 0.0, 0.0)
        actor_sphere.SetMapper(pd_sphere)
        actor_sphere.GetProperty().SetInterpolationToPBR()
        actor_sphere.GetProperty().SetColor(colors.GetColor3d('White'))
        actor_sphere.GetProperty().SetMetallic(1.0)
--
    cube_map = vtkTexture()
    cube_map.CubeMapOn()

    i = 0
    for fn in cubemap:
        # Read the images.
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn))
        img_reader.SetFileName(str(fn))

        # Each image must be flipped in Y due to canvas
        #  versus vtk ordering.
        flip = vtkImageFlip()
        flip.SetInputConnection(img_reader.GetOutputPort(0))
        flip.SetFilteredAxis(1)  # flip y axis
        cube_map.SetInputConnection(i, flip.GetOutputPort())
        i += 1

--
    texture = vtkTexture()

    suffix = fn_path.suffix.lower()
    if suffix in ['.jpeg', '.jpg', '.png']:
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn_path))
        img_reader.SetFileName(str(fn_path))

        texture.SetInputConnection(img_reader.GetOutputPort(0))

--
        reader = vtkHDRReader()
        extensions = reader.GetFileExtensions()
        # Check the image can be read.
        if not reader.CanReadFile(str(fn_path)):
            print('CanReadFile failed for ', fn_path)
            return None
--
    colors = vtkNamedColors()

    ren = vtkOpenGLRenderer()
    ren.SetBackground(colors.GetColor3d('Black'))
    ren.AutomaticLightCreationOff()

    light = vtkLight()
    light.SetPosition(2.0, 0.0, 2.0)
    light.SetFocalPoint(0.0, 0.0, 0.0)

    ren.AddLight(light)

    ren_win = vtkRenderWindow()
    ren_win.SetSize(600, 600)
    ren_win.AddRenderer(ren)

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(ren_win)

    style = vtkInteractorStyleTrackballCamera()
    iren.SetInteractorStyle(style)

    skybox = vtkSkybox()

    irradiance = ren.GetEnvMapIrradiance()
    irradiance.SetIrradianceStep(0.3)

    # Choose how to generate the skybox.
--
    cube = vtkCubeSource()

    triangulation = vtkTriangleFilter()
    triangulation.SetInputConnection(cube.GetOutputPort())

    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(triangulation.GetOutputPort())

    mapper = vtkPolyDataMapper()
    mapper.SetInputConnection(tangents.GetOutputPort())

    material_reader = vtkPNGReader()
    material_reader.SetFileName(parameters['material'])

    material = vtkTexture()
    material.InterpolateOn()
    material.SetInputConnection(material_reader.GetOutputPort())

    albedo_reader = vtkPNGReader()
    albedo_reader.SetFileName(parameters['albedo'])

    albedo = vtkTexture()
    albedo.UseSRGBColorSpaceOn()
    albedo.InterpolateOn()
    albedo.SetInputConnection(albedo_reader.GetOutputPort())

    normal_reader = vtkPNGReader()
    normal_reader.SetFileName(parameters['normal'])

    normal = vtkTexture()
    normal.InterpolateOn()
    normal.SetInputConnection(normal_reader.GetOutputPort())

    anisotropy_reader = vtkPNGReader()
    anisotropy_reader.SetFileName(parameters['anisotropy'])

    anisotropy = vtkTexture()
    anisotropy.InterpolateOn()
    anisotropy.SetInputConnection(anisotropy_reader.GetOutputPort())

    actor = vtkActor()
    actor.SetOrientation(0.0, 25.0, 0.0)
    actor.SetMapper(mapper)
    actor.GetProperty().SetInterpolationToPBR()

    # Set metallic, roughness, anisotropy and anisotropyRotation
--
    cube_map = vtkTexture()
    cube_map.CubeMapOn()

    i = 0
    for fn in cubemap:
        # Read the images.
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn))
        img_reader.SetFileName(str(fn))

        # Each image must be flipped in Y due to canvas
        #  versus vtk ordering.
        flip = vtkImageFlip()
        flip.SetInputConnection(img_reader.GetOutputPort(0))
        flip.SetFilteredAxis(1)  # flip y axis
        cube_map.SetInputConnection(i, flip.GetOutputPort())
        i += 1

--
    texture = vtkTexture()

    suffix = fn_path.suffix.lower()
    if suffix in ['.jpeg', '.jpg', '.png']:
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn_path))
        img_reader.SetFileName(str(fn_path))

        texture.SetInputConnection(img_reader.GetOutputPort(0))

--
        reader = vtkHDRReader()
        extensions = reader.GetFileExtensions()
        # Check the image can be read.
        if not reader.CanReadFile(str(fn_path)):
            print('CanReadFile failed for ', fn_path)
            return None
--
    colors = vtkNamedColors()
    colors.SetColor('Brass', [184, 115, 51, 255])
    colors.SetColor('DarkTeal', [0, 128, 77, 255])

    ren = vtkOpenGLRenderer()
    ren.SetBackground(colors.GetColor3d('Black'))

    ren_win = vtkRenderWindow()
    ren_win.SetSize(600, 600)
    ren_win.AddRenderer(ren)

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(ren_win)

    style = vtkInteractorStyleTrackballCamera()
    iren.SetInteractorStyle(style)

    skybox = vtkOpenGLSkybox()

    irradiance = ren.GetEnvMapIrradiance()
    irradiance.SetIrradianceStep(0.3)

    # Choose how to generate the skybox.
--
    sphere = vtkSphereSource()
    sphere.SetThetaResolution(75)
    sphere.SetPhiResolution(75)

    pd_sphere = vtkPolyDataMapper()
    pd_sphere.SetInputConnection(sphere.GetOutputPort())

    for i in range(0, 6):
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 0.0, 0.0)
        actor_sphere.SetMapper(pd_sphere)
        actor_sphere.GetProperty().SetInterpolationToPBR()
        actor_sphere.GetProperty().SetColor(colors.GetColor3d('Brass'))
        actor_sphere.GetProperty().SetMetallic(1.0)
--
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 1.0, 0.0)
        actor_sphere.SetMapper(pd_sphere)
        actor_sphere.GetProperty().SetInterpolationToPBR()
        actor_sphere.GetProperty().SetColor(colors.GetColor3d('Brass'))
        actor_sphere.GetProperty().SetMetallic(1.0)
--
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 2.0, 0.0)
        actor_sphere.SetMapper(pd_sphere)
        actor_sphere.GetProperty().SetInterpolationToPBR()
        actor_sphere.GetProperty().SetColor(colors.GetColor3d('White'))
        actor_sphere.GetProperty().SetMetallic(1.0)
--
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 3.0, 0.0)
        actor_sphere.SetMapper(pd_sphere)
        actor_sphere.GetProperty().SetInterpolationToPBR()
        actor_sphere.GetProperty().SetColor(colors.GetColor3d('White'))
        actor_sphere.GetProperty().SetRoughness(0.1)
--
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 4.0, 0.0)
        actor_sphere.SetMapper(pd_sphere)
        actor_sphere.GetProperty().SetInterpolationToPBR()
        actor_sphere.GetProperty().SetColor(colors.GetColor3d('DarkTeal'))
        actor_sphere.GetProperty().SetBaseIOR(1.0 + i / 3.0)
--
    cube_map = vtkTexture()
    cube_map.CubeMapOn()

    i = 0
    for fn in cubemap:
        # Read the images.
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn))
        img_reader.SetFileName(str(fn))

        # Each image must be flipped in Y due to canvas
        #  versus vtk ordering.
        flip = vtkImageFlip()
        flip.SetInputConnection(img_reader.GetOutputPort(0))
        flip.SetFilteredAxis(1)  # flip y axis
        cube_map.SetInputConnection(i, flip.GetOutputPort())
        i += 1

--
    texture = vtkTexture()

    suffix = fn_path.suffix.lower()
    if suffix in ['.jpeg', '.jpg', '.png']:
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn_path))
        img_reader.SetFileName(str(fn_path))

        texture.SetInputConnection(img_reader.GetOutputPort(0))

--
        reader = vtkHDRReader()
        extensions = reader.GetFileExtensions()
        # Check the image can be read.
        if not reader.CanReadFile(str(fn_path)):
            print('CanReadFile failed for ', fn_path)
            return None
--
    colors = vtkNamedColors()
    colors.SetColor('Brass', [184, 115, 51, 255])

    ren = vtkOpenGLRenderer()
    ren.SetBackground(colors.GetColor3d('Black'))

    ren_win = vtkRenderWindow()
    ren_win.SetSize(600, 600)
    ren_win.AddRenderer(ren)

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(ren_win)

    style = vtkInteractorStyleTrackballCamera()
    iren.SetInteractorStyle(style)

    skybox = vtkOpenGLSkybox()

    irradiance = ren.GetEnvMapIrradiance()
    irradiance.SetIrradianceStep(0.3)

    # Choose how to generate the skybox.
--
    sphere = vtkSphereSource()
    sphere.SetThetaResolution(100)
    sphere.SetPhiResolution(100)

    pd_sphere = vtkPolyDataMapper()
    pd_sphere.SetInputConnection(sphere.GetOutputPort())

    for i in range(0, 6):
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 0.0, 0.0)
        actor_sphere.SetMapper(pd_sphere)
        actor_sphere.GetProperty().SetInterpolationToPBR()
        actor_sphere.GetProperty().SetColor(colors.GetColor3d('White'))
        actor_sphere.GetProperty().SetMetallic(1.0)
--
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 1.0, 0.0)
        actor_sphere.SetMapper(pd_sphere)
        actor_sphere.GetProperty().SetInterpolationToPBR()
        actor_sphere.GetProperty().SetColor(colors.GetColor3d('Brass'))
        actor_sphere.GetProperty().SetMetallic(1.0)
--
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 2.0, 0.0)
        actor_sphere.SetMapper(pd_sphere)
        actor_sphere.GetProperty().SetInterpolationToPBR()
        actor_sphere.GetProperty().SetColor(colors.GetColor3d('Black'))
        actor_sphere.GetProperty().SetRoughness(i / 5.0)
--
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 3.0, 0.0)
        actor_sphere.SetMapper(pd_sphere)
        actor_sphere.GetProperty().SetInterpolationToPBR()
        actor_sphere.GetProperty().SetColor(colors.GetColor3d('Cyan'))
        actor_sphere.GetProperty().SetRoughness(i / 5.0)
--
        actor_sphere = vtkActor()
        actor_sphere.SetPosition(i, 4.0, 0.0)
        actor_sphere.SetMapper(pd_sphere)
        actor_sphere.GetProperty().SetInterpolationToPBR()
        actor_sphere.GetProperty().SetColor(colors.GetColor3d('Red'))
        actor_sphere.GetProperty().SetRoughness(i / 5.0)
--
    cube_map = vtkTexture()
    cube_map.CubeMapOn()

    i = 0
    for fn in cubemap:
        # Read the images.
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn))
        img_reader.SetFileName(str(fn))

        # Each image must be flipped in Y due to canvas
        #  versus vtk ordering.
        flip = vtkImageFlip()
        flip.SetInputConnection(img_reader.GetOutputPort(0))
        flip.SetFilteredAxis(1)  # flip y axis
        cube_map.SetInputConnection(i, flip.GetOutputPort())
        i += 1

--
    texture = vtkTexture()

    suffix = fn_path.suffix.lower()
    if suffix in ['.jpeg', '.jpg', '.png']:
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn_path))
        img_reader.SetFileName(str(fn_path))

        texture.SetInputConnection(img_reader.GetOutputPort(0))

--
        reader = vtkHDRReader()
        extensions = reader.GetFileExtensions()
        # Check the image can be read.
        if not reader.CanReadFile(str(fn_path)):
            print('CanReadFile failed for ', fn_path)
            return None
--
    colors = vtkNamedColors()

    # Default background color.
    colors.SetColor('BkgColor', [26, 51, 102, 255])

    # Default background color.
--
    ren1 = vtkRenderer()
    # ren2 = vtkOpenGLRenderer()
    ren2 = vtkRenderer()
    ren1.SetBackground(colors.GetColor3d('Snow'))
    ren2.SetBackground(colors.GetColor3d(parameters['bkgcolor']))

    render_window = vtkRenderWindow()
    # The order here is important.
    # This ensures that the sliders will be in ren1.
    render_window.AddRenderer(ren2)
    render_window.AddRenderer(ren1)
    ren1.SetViewport(0.0, 0.0, 0.2, 1.0)
--
    interactor = vtkRenderWindowInteractor()
    interactor.SetRenderWindow(render_window)
    style = vtkInteractorStyleTrackballCamera()
    interactor.SetInteractorStyle(style)

    # Set up tone mapping, so we can vary the exposure.
    # Custom Passes.
    camera_p = vtkCameraPass()
    seq = vtkSequencePass()
    opaque = vtkOpaquePass()
    lights = vtkLightsPass()
    overlay = vtkOverlayPass()

    passes = vtkRenderPassCollection()
    passes.AddItem(lights)
    passes.AddItem(opaque)
    passes.AddItem(overlay)
    seq.SetPasses(passes)
    camera_p.SetDelegatePass(seq)
--
    tone_mapping_p = vtkToneMappingPass()
    tone_mapping_p.SetDelegatePass(camera_p)

    if use_tonemapping:
        ren2.SetPass(tone_mapping_p)

    skybox = vtkSkybox()

    irradiance = ren2.GetEnvMapIrradiance()
    irradiance.SetIrradianceStep(0.3)

    # Choose how to generate the skybox.
--
    mapper = vtkPolyDataMapper()
    mapper.SetInputData(source)

    actor = vtkActor()
    actor.SetMapper(mapper)
    # Enable PBR on the model.
    actor.GetProperty().SetInterpolationToPBR()
    # Configure the basic properties.
    # Set the model colour.
--
            cam_orient_manipulator = vtkCameraOrientationWidget()
            cam_orient_manipulator.SetParentRenderer(ren2)
            # Enable the widget.
            cam_orient_manipulator.On()
        except AttributeError:
            pass
--
        axes = vtkAxesActor()
        widget = vtkOrientationMarkerWidget()
        rgba = [0.0, 0.0, 0.0, 0.0]
        colors.GetColor("Carrot", rgba)
        widget.SetOutlineColor(rgba[0], rgba[1], rgba[2])
        widget.SetOrientationMarker(axes)
        widget.SetInteractor(interactor)
--
        ver = vtkVersion()
        vtk_version_number = 10000000000 * ver.GetVTKMajorVersion() + 100000000 * ver.GetVTKMinorVersion() \
                             + ver.GetVTKBuildVersion()
    if vtk_version_number >= needed_version:
        return True
    else:
--
    cube_map = vtkTexture()
    cube_map.CubeMapOn()

    i = 0
    for fn in cubemap:
        # Read the images.
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn))
        img_reader.SetFileName(str(fn))

        # Each image must be flipped in Y due to canvas
        #  versus vtk ordering.
        flip = vtkImageFlip()
        flip.SetInputConnection(img_reader.GetOutputPort(0))
        flip.SetFilteredAxis(1)  # flip y axis
        cube_map.SetInputConnection(i, flip.GetOutputPort())
        i += 1

--
    texture = vtkTexture()

    suffix = fn_path.suffix.lower()
    if suffix in ['.jpeg', '.jpg', '.png']:
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn_path))
        img_reader.SetFileName(str(fn_path))

        texture.SetInputConnection(img_reader.GetOutputPort(0))

--
        reader = vtkHDRReader()
        extensions = reader.GetFileExtensions()
        # Check the image can be read.
        if not reader.CanReadFile(str(fn_path)):
            print('CanReadFile failed for ', fn_path)
            return None
--
    reader_factory = vtkImageReader2Factory()
    img_reader = reader_factory.CreateImageReader2(str(image_path))
    img_reader.SetFileName(str(image_path))

    texture = vtkTexture()
    texture.InterpolateOn()
    texture.SetInputConnection(img_reader.GetOutputPort())
    texture.Update()

    return texture
--
    surface = vtkParametricBoy()

    source = vtkParametricFunctionSource()
    source.SetUResolution(u_resolution)
    source.SetVResolution(v_resolution)
    source.GenerateTextureCoordinatesOn()
    source.SetParametricFunction(surface)
    source.Update()
--
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(source.GetOutputPort())
    tangents.Update()
    return tangents.GetOutput()


--
    surface = vtkParametricMobius()
    surface.SetMinimumV(-0.25)
    surface.SetMaximumV(0.25)

    source = vtkParametricFunctionSource()
    source.SetUResolution(u_resolution)
    source.SetVResolution(v_resolution)
    source.GenerateTextureCoordinatesOn()
    source.SetParametricFunction(surface)
    source.Update()
--
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(source.GetOutputPort())
    tangents.Update()

    transform = vtkTransform()
    transform.RotateX(-90.0)
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputConnection(tangents.GetOutputPort())
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    return transform_filter.GetOutput()
--
    surface = vtkParametricRandomHills()
    surface.SetRandomSeed(1)
    surface.SetNumberOfHills(30)
    # If you want a plane
    # surface.SetHillAmplitude(0)

    source = vtkParametricFunctionSource()
    source.SetUResolution(u_resolution)
    source.SetVResolution(v_resolution)
    source.GenerateTextureCoordinatesOn()
    source.SetParametricFunction(surface)
    source.Update()
--
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(source.GetOutputPort())
    tangents.Update()

    transform = vtkTransform()
    transform.Translate(0.0, 5.0, 15.0)
    transform.RotateX(-90.0)
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputConnection(tangents.GetOutputPort())
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    return transform_filter.GetOutput()
--
    surface = vtkParametricTorus()

    source = vtkParametricFunctionSource()
    source.SetUResolution(u_resolution)
    source.SetVResolution(v_resolution)
    source.GenerateTextureCoordinatesOn()
    source.SetParametricFunction(surface)
    source.Update()
--
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(source.GetOutputPort())
    tangents.Update()

    transform = vtkTransform()
    transform.RotateX(-90.0)
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputConnection(tangents.GetOutputPort())
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    return transform_filter.GetOutput()
--
    surface = vtkTexturedSphereSource()
    surface.SetThetaResolution(theta_resolution)
    surface.SetPhiResolution(phi_resolution)

    # Now the tangents.
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(surface.GetOutputPort())
    tangents.Update()
    return tangents.GetOutput()


--
    surface = vtkTexturedSphereSource()
    surface.SetThetaResolution(theta_resolution)
    surface.SetPhiResolution(phi_resolution)

    clip_plane = vtkPlane()
    clip_plane.SetOrigin(0, 0.3, 0)
    clip_plane.SetNormal(0, -1, 0)

    clipper = vtkClipPolyData()
    clipper.SetInputConnection(surface.GetOutputPort())
    clipper.SetClipFunction(clip_plane)
    clipper.GenerateClippedOutputOn()

    # Now the tangents.
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(clipper.GetOutputPort())
    tangents.Update()
    return tangents.GetOutput()


--
    surface = vtkCubeSource()

    # Triangulate.
    triangulation = vtkTriangleFilter()
    triangulation.SetInputConnection(surface.GetOutputPort())

    # Subdivide the triangles
    subdivide = vtkLinearSubdivisionFilter()
    subdivide.SetInputConnection(triangulation.GetOutputPort())
    subdivide.SetNumberOfSubdivisions(3)

    # Now the tangents.
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(subdivide.GetOutputPort())
    tangents.Update()
    return tangents.GetOutput()


--
    surface = vtkCubeSource()

    # Triangulate.
    triangulation = vtkTriangleFilter()
    triangulation.SetInputConnection(surface.GetOutputPort())

    # Subdivide the triangles
    subdivide = vtkLinearSubdivisionFilter()
    subdivide.SetInputConnection(triangulation.GetOutputPort())
    subdivide.SetNumberOfSubdivisions(5)

    clip_plane = vtkPlane()
    clip_plane.SetOrigin(0, 0.3, 0)
    clip_plane.SetNormal(0, -1, -1)

    clipper = vtkClipPolyData()
    clipper.SetInputConnection(subdivide.GetOutputPort())
    clipper.SetClipFunction(clip_plane)
    clipper.GenerateClippedOutputOn()

    cleaner = vtkCleanPolyData()
    cleaner.SetInputConnection(clipper.GetOutputPort())
    cleaner.SetTolerance(0.005)
    cleaner.Update()

    normals = vtkPolyDataNormals()
    normals.SetInputConnection(cleaner.GetOutputPort())
    normals.FlipNormalsOn()
    normals.SetFeatureAngle(60)

    # Now the tangents.
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(normals.GetOutputPort())
    tangents.ComputeCellTangentsOn()
    tangents.ComputePointTangentsOn()
    tangents.Update()
    return tangents.GetOutput()
--
    t_coords = vtkFloatArray()
    t_coords.SetNumberOfComponents(2)
    t_coords.SetNumberOfTuples(num_pts)
    t_coords.SetName('Texture Coordinates')
    pt_id = 0
    u = u0
--
    colors = vtkNamedColors()

    slider = vtkSliderRepresentation2D()

    slider.SetMinimumValue(properties.minimum_value)
    slider.SetMaximumValue(properties.maximum_value)
    slider.SetValue(properties.initial_value)
    slider.SetTitleText(properties.title)
--
    slider_widget = vtkSliderWidget()
    slider_widget.SetRepresentation(slider)

    return slider_widget


--
            w2if = vtkWindowToImageFilter()
            w2if.SetInput(caller.GetRenderWindow())
            w2if.SetScale(self.image_quality, self.image_quality)
            if self.rgba:
                w2if.SetInputBufferTypeToRGBA()
            else:
--
                writer = vtkJPEGWriter()
            else:
                writer = vtkPNGWriter()
            writer.SetFileName(self.path)
            writer.SetInputData(w2if.GetOutput())
            writer.Write()
            print('Screenshot saved to:', self.path)

--
    colors = vtkNamedColors()

    # Default background color.
    colors.SetColor('BkgColor', [26, 51, 102, 255])

    fn, surface_name, use_cubemap, use_tonemapping = get_program_parameters()
--
    ren1 = vtkRenderer()
    # ren2 = vtkOpenGLRenderer()
    ren2 = vtkRenderer()
    ren1.SetBackground(colors.GetColor3d('Snow'))
    ren2.SetBackground(colors.GetColor3d(parameters['bkgcolor']))

    render_window = vtkRenderWindow()
    # The order here is important.
    # This ensures that the sliders will be in ren1.
    render_window.AddRenderer(ren2)
    render_window.AddRenderer(ren1)
    ren1.SetViewport(0.0, 0.0, 0.2, 1.0)
--
    interactor = vtkRenderWindowInteractor()
    interactor.SetRenderWindow(render_window)
    style = vtkInteractorStyleTrackballCamera()
    interactor.SetInteractorStyle(style)

    # Set up tone mapping, so we can vary the exposure.
    # Custom Passes.
    camera_p = vtkCameraPass()
    seq = vtkSequencePass()
    opaque = vtkOpaquePass()
    lights = vtkLightsPass()
    overlay = vtkOverlayPass()

    passes = vtkRenderPassCollection()
    passes.AddItem(lights)
    passes.AddItem(opaque)
    passes.AddItem(overlay)
    seq.SetPasses(passes)
    camera_p.SetDelegatePass(seq)
--
    tone_mapping_p = vtkToneMappingPass()
    tone_mapping_p.SetDelegatePass(camera_p)

    if use_tonemapping:
        ren2.SetPass(tone_mapping_p)

    skybox = vtkSkybox()

    irradiance = ren2.GetEnvMapIrradiance()
    irradiance.SetIrradianceStep(0.3)

    # Choose how to generate the skybox.
--
    mapper = vtkPolyDataMapper()
    mapper.SetInputData(source)

    actor = vtkActor()
    actor.SetMapper(mapper)
    # Enable PBR on the model.
    actor.GetProperty().SetInterpolationToPBR()
    # Configure the basic properties.
    actor.GetProperty().SetColor(colors.GetColor3d(parameters['objcolor']))
--
            cam_orient_manipulator = vtkCameraOrientationWidget()
            cam_orient_manipulator.SetParentRenderer(ren2)
            # Enable the widget.
            cam_orient_manipulator.On()
        except AttributeError:
            pass
--
        axes = vtkAxesActor()
        widget = vtkOrientationMarkerWidget()
        rgba = [0.0, 0.0, 0.0, 0.0]
        colors.GetColor("Carrot", rgba)
        widget.SetOutlineColor(rgba[0], rgba[1], rgba[2])
        widget.SetOrientationMarker(axes)
        widget.SetInteractor(interactor)
--
        ver = vtkVersion()
        vtk_version_number = 10000000000 * ver.GetVTKMajorVersion() + 100000000 * ver.GetVTKMinorVersion() \
                             + ver.GetVTKBuildVersion()
    if vtk_version_number >= needed_version:
        return True
    else:
--
    cube_map = vtkTexture()
    cube_map.CubeMapOn()

    i = 0
    for fn in cubemap:
        # Read the images.
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn))
        img_reader.SetFileName(str(fn))

        # Each image must be flipped in Y due to canvas
        #  versus vtk ordering.
        flip = vtkImageFlip()
        flip.SetInputConnection(img_reader.GetOutputPort(0))
        flip.SetFilteredAxis(1)  # flip y axis
        cube_map.SetInputConnection(i, flip.GetOutputPort())
        i += 1

--
    texture = vtkTexture()

    suffix = fn_path.suffix.lower()
    if suffix in ['.jpeg', '.jpg', '.png']:
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn_path))
        img_reader.SetFileName(str(fn_path))

        texture.SetInputConnection(img_reader.GetOutputPort(0))

--
        reader = vtkHDRReader()
        extensions = reader.GetFileExtensions()
        # Check the image can be read.
        if not reader.CanReadFile(str(fn_path)):
            print('CanReadFile failed for ', fn_path)
            return None
--
    surface = vtkParametricBoy()

    source = vtkParametricFunctionSource()
    source.SetUResolution(u_resolution)
    source.SetVResolution(v_resolution)
    source.GenerateTextureCoordinatesOn()
    source.SetParametricFunction(surface)
    source.Update()
--
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(source.GetOutputPort())
    tangents.Update()
    return tangents.GetOutput()


--
    surface = vtkParametricMobius()
    surface.SetMinimumV(-0.25)
    surface.SetMaximumV(0.25)

    source = vtkParametricFunctionSource()
    source.SetUResolution(u_resolution)
    source.SetVResolution(v_resolution)
    source.GenerateTextureCoordinatesOn()
    source.SetParametricFunction(surface)
    source.Update()
--
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(source.GetOutputPort())
    tangents.Update()

    transform = vtkTransform()
    transform.RotateX(-90.0)
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputConnection(tangents.GetOutputPort())
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    return transform_filter.GetOutput()
--
    surface = vtkParametricRandomHills()
    surface.SetRandomSeed(1)
    surface.SetNumberOfHills(30)
    # If you want a plane
    # surface.SetHillAmplitude(0)

    source = vtkParametricFunctionSource()
    source.SetUResolution(u_resolution)
    source.SetVResolution(v_resolution)
    source.GenerateTextureCoordinatesOn()
    source.SetParametricFunction(surface)
    source.Update()
--
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(source.GetOutputPort())
    tangents.Update()

    transform = vtkTransform()
    transform.Translate(0.0, 5.0, 15.0)
    transform.RotateX(-90.0)
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputConnection(tangents.GetOutputPort())
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    return transform_filter.GetOutput()
--
    surface = vtkParametricTorus()

    source = vtkParametricFunctionSource()
    source.SetUResolution(u_resolution)
    source.SetVResolution(v_resolution)
    source.GenerateTextureCoordinatesOn()
    source.SetParametricFunction(surface)
    source.Update()
--
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(source.GetOutputPort())
    tangents.Update()

    transform = vtkTransform()
    transform.RotateX(-90.0)
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputConnection(tangents.GetOutputPort())
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    return transform_filter.GetOutput()
--
    surface = vtkTexturedSphereSource()
    surface.SetThetaResolution(theta_resolution)
    surface.SetPhiResolution(phi_resolution)

    # Now the tangents.
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(surface.GetOutputPort())
    tangents.Update()
    return tangents.GetOutput()


--
    surface = vtkTexturedSphereSource()
    surface.SetThetaResolution(theta_resolution)
    surface.SetPhiResolution(phi_resolution)

    clip_plane = vtkPlane()
    clip_plane.SetOrigin(0, 0.3, 0)
    clip_plane.SetNormal(0, -1, 0)

    clipper = vtkClipPolyData()
    clipper.SetInputConnection(surface.GetOutputPort())
    clipper.SetClipFunction(clip_plane)
    clipper.GenerateClippedOutputOn()

    # Now the tangents.
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(clipper.GetOutputPort())
    tangents.Update()
    return tangents.GetOutput()


--
    surface = vtkCubeSource()

    # Triangulate.
    triangulation = vtkTriangleFilter()
    triangulation.SetInputConnection(surface.GetOutputPort())

    # Subdivide the triangles
    subdivide = vtkLinearSubdivisionFilter()
    subdivide.SetInputConnection(triangulation.GetOutputPort())
    subdivide.SetNumberOfSubdivisions(3)

    # Now the tangents.
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(subdivide.GetOutputPort())
    tangents.Update()
    return tangents.GetOutput()


--
    surface = vtkCubeSource()

    # Triangulate.
    triangulation = vtkTriangleFilter()
    triangulation.SetInputConnection(surface.GetOutputPort())

    # Subdivide the triangles
    subdivide = vtkLinearSubdivisionFilter()
    subdivide.SetInputConnection(triangulation.GetOutputPort())
    subdivide.SetNumberOfSubdivisions(5)

    clip_plane = vtkPlane()
    clip_plane.SetOrigin(0, 0.3, 0)
    clip_plane.SetNormal(0, -1, -1)

    clipper = vtkClipPolyData()
    clipper.SetInputConnection(subdivide.GetOutputPort())
    clipper.SetClipFunction(clip_plane)
    clipper.GenerateClippedOutputOn()

    cleaner = vtkCleanPolyData()
    cleaner.SetInputConnection(clipper.GetOutputPort())
    cleaner.SetTolerance(0.005)
    cleaner.Update()

    normals = vtkPolyDataNormals()
    normals.SetInputConnection(cleaner.GetOutputPort())
    normals.FlipNormalsOn()
    normals.SetFeatureAngle(60)

    # Now the tangents.
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(normals.GetOutputPort())
    tangents.ComputeCellTangentsOn()
    tangents.ComputePointTangentsOn()
    tangents.Update()
    return tangents.GetOutput()
--
    t_coords = vtkFloatArray()
    t_coords.SetNumberOfComponents(2)
    t_coords.SetNumberOfTuples(num_pts)
    t_coords.SetName('Texture Coordinates')
    pt_id = 0
    u = u0
--
    colors = vtkNamedColors()

    slider = vtkSliderRepresentation2D()

    slider.SetMinimumValue(properties.minimum_value)
    slider.SetMaximumValue(properties.maximum_value)
    slider.SetValue(properties.initial_value)
    slider.SetTitleText(properties.title)
--
    slider_widget = vtkSliderWidget()
    slider_widget.SetRepresentation(slider)

    return slider_widget


--
            w2if = vtkWindowToImageFilter()
            w2if.SetInput(caller.GetRenderWindow())
            w2if.SetScale(self.image_quality, self.image_quality)
            if self.rgba:
                w2if.SetInputBufferTypeToRGBA()
            else:
--
                writer = vtkJPEGWriter()
            else:
                writer = vtkPNGWriter()
            writer.SetFileName(self.path)
            writer.SetInputData(w2if.GetOutput())
            writer.Write()
            print('Screenshot saved to:', self.path)

--
    colors = vtkNamedColors()

    # Default background color.
    colors.SetColor('BkgColor', [26, 51, 102, 255])
    colors.SetColor('VTKBlue', [6, 79, 141, 255])
    # Let's make a complementary colour to VTKBlue.
--
    ren1 = vtkRenderer()
    # ren2 = vtkOpenGLRenderer()
    ren2 = vtkRenderer()
    ren1.SetBackground(colors.GetColor3d('Snow'))
    ren2.SetBackground(colors.GetColor3d(parameters['bkgcolor']))

    render_window = vtkRenderWindow()
    # The order here is important.
    # This ensures that the sliders will be in ren1.
    render_window.AddRenderer(ren2)
    render_window.AddRenderer(ren1)
    ren1.SetViewport(0.0, 0.0, 0.2, 1.0)
--
    interactor = vtkRenderWindowInteractor()
    interactor.SetRenderWindow(render_window)
    style = vtkInteractorStyleTrackballCamera()
    interactor.SetInteractorStyle(style)

    # Set up tone mapping, so we can vary the exposure.
    # Custom Passes.
    camera_p = vtkCameraPass()
    seq = vtkSequencePass()
    opaque = vtkOpaquePass()
    lights = vtkLightsPass()
    overlay = vtkOverlayPass()

    passes = vtkRenderPassCollection()
    passes.AddItem(lights)
    passes.AddItem(opaque)
    passes.AddItem(overlay)
    seq.SetPasses(passes)
    camera_p.SetDelegatePass(seq)
--
    tone_mapping_p = vtkToneMappingPass()
    tone_mapping_p.SetDelegatePass(camera_p)

    if use_tonemapping:
        ren2.SetPass(tone_mapping_p)

    skybox = vtkSkybox()

    irradiance = ren2.GetEnvMapIrradiance()
    irradiance.SetIrradianceStep(0.3)

    # Choose how to generate the skybox.
--
    mapper = vtkPolyDataMapper()
    mapper.SetInputData(source)

    actor = vtkActor()
    actor.SetMapper(mapper)
    # Enable PBR on the model.
    actor.GetProperty().SetInterpolationToPBR()
    # Configure the basic properties.
    actor.GetProperty().SetColor(colors.GetColor3d(parameters['objcolor']))
--
            cam_orient_manipulator = vtkCameraOrientationWidget()
            cam_orient_manipulator.SetParentRenderer(ren2)
            # Enable the widget.
            cam_orient_manipulator.On()
        except AttributeError:
            pass
--
        axes = vtkAxesActor()
        widget = vtkOrientationMarkerWidget()
        rgba = [0.0, 0.0, 0.0, 0.0]
        colors.GetColor("Carrot", rgba)
        widget.SetOutlineColor(rgba[0], rgba[1], rgba[2])
        widget.SetOrientationMarker(axes)
        widget.SetInteractor(interactor)
--
        ver = vtkVersion()
        vtk_version_number = 10000000000 * ver.GetVTKMajorVersion() + 100000000 * ver.GetVTKMinorVersion() \
                             + ver.GetVTKBuildVersion()
    if vtk_version_number >= needed_version:
        return True
    else:
--
    cube_map = vtkTexture()
    cube_map.CubeMapOn()

    i = 0
    for fn in cubemap:
        # Read the images.
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn))
        img_reader.SetFileName(str(fn))

        # Each image must be flipped in Y due to canvas
        #  versus vtk ordering.
        flip = vtkImageFlip()
        flip.SetInputConnection(img_reader.GetOutputPort(0))
        flip.SetFilteredAxis(1)  # flip y axis
        cube_map.SetInputConnection(i, flip.GetOutputPort())
        i += 1

--
    texture = vtkTexture()

    suffix = fn_path.suffix.lower()
    if suffix in ['.jpeg', '.jpg', '.png']:
        reader_factory = vtkImageReader2Factory()
        img_reader = reader_factory.CreateImageReader2(str(fn_path))
        img_reader.SetFileName(str(fn_path))

        texture.SetInputConnection(img_reader.GetOutputPort(0))

--
        reader = vtkHDRReader()
        extensions = reader.GetFileExtensions()
        # Check the image can be read.
        if not reader.CanReadFile(str(fn_path)):
            print('CanReadFile failed for ', fn_path)
            return None
--
    reader_factory = vtkImageReader2Factory()
    img_reader = reader_factory.CreateImageReader2(str(image_path))
    img_reader.SetFileName(str(image_path))

    texture = vtkTexture()
    texture.InterpolateOn()
    texture.SetInputConnection(img_reader.GetOutputPort(0))
    texture.Update()

    return texture
--
    surface = vtkParametricBoy()

    source = vtkParametricFunctionSource()
    source.SetUResolution(u_resolution)
    source.SetVResolution(v_resolution)
    source.GenerateTextureCoordinatesOn()
    source.SetParametricFunction(surface)
    source.Update()
--
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(source.GetOutputPort())
    tangents.Update()
    return tangents.GetOutput()


--
    surface = vtkParametricMobius()
    surface.SetMinimumV(-0.25)
    surface.SetMaximumV(0.25)

    source = vtkParametricFunctionSource()
    source.SetUResolution(u_resolution)
    source.SetVResolution(v_resolution)
    source.GenerateTextureCoordinatesOn()
    source.SetParametricFunction(surface)
    source.Update()
--
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(source.GetOutputPort())
    tangents.Update()

    transform = vtkTransform()
    transform.RotateX(-90.0)
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputConnection(tangents.GetOutputPort())
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    return transform_filter.GetOutput()
--
    surface = vtkParametricRandomHills()
    surface.SetRandomSeed(1)
    surface.SetNumberOfHills(30)
    # If you want a plane
    # surface.SetHillAmplitude(0)

    source = vtkParametricFunctionSource()
    source.SetUResolution(u_resolution)
    source.SetVResolution(v_resolution)
    source.GenerateTextureCoordinatesOn()
    source.SetParametricFunction(surface)
    source.Update()
--
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(source.GetOutputPort())
    tangents.Update()

    transform = vtkTransform()
    transform.Translate(0.0, 5.0, 15.0)
    transform.RotateX(-90.0)
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputConnection(tangents.GetOutputPort())
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    return transform_filter.GetOutput()
--
    surface = vtkParametricTorus()

    source = vtkParametricFunctionSource()
    source.SetUResolution(u_resolution)
    source.SetVResolution(v_resolution)
    source.GenerateTextureCoordinatesOn()
    source.SetParametricFunction(surface)
    source.Update()
--
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(source.GetOutputPort())
    tangents.Update()

    transform = vtkTransform()
    transform.RotateX(-90.0)
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputConnection(tangents.GetOutputPort())
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    return transform_filter.GetOutput()
--
    surface = vtkTexturedSphereSource()
    surface.SetThetaResolution(theta_resolution)
    surface.SetPhiResolution(phi_resolution)

    # Now the tangents.
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(surface.GetOutputPort())
    tangents.Update()
    return tangents.GetOutput()


--
    surface = vtkTexturedSphereSource()
    surface.SetThetaResolution(theta_resolution)
    surface.SetPhiResolution(phi_resolution)

    clip_plane = vtkPlane()
    clip_plane.SetOrigin(0, 0.3, 0)
    clip_plane.SetNormal(0, -1, 0)

    clipper = vtkClipPolyData()
    clipper.SetInputConnection(surface.GetOutputPort())
    clipper.SetClipFunction(clip_plane)
    clipper.GenerateClippedOutputOn()

    # Now the tangents.
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(clipper.GetOutputPort())
    tangents.Update()
    return tangents.GetOutput()


--
    surface = vtkCubeSource()

    # Triangulate.
    triangulation = vtkTriangleFilter()
    triangulation.SetInputConnection(surface.GetOutputPort())

    # Subdivide the triangles
    subdivide = vtkLinearSubdivisionFilter()
    subdivide.SetInputConnection(triangulation.GetOutputPort())
    subdivide.SetNumberOfSubdivisions(3)

    # Now the tangents.
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(subdivide.GetOutputPort())
    tangents.Update()
    return tangents.GetOutput()


--
    surface = vtkCubeSource()

    # Triangulate.
    triangulation = vtkTriangleFilter()
    triangulation.SetInputConnection(surface.GetOutputPort())

    # Subdivide the triangles
    subdivide = vtkLinearSubdivisionFilter()
    subdivide.SetInputConnection(triangulation.GetOutputPort())
    subdivide.SetNumberOfSubdivisions(5)

    clip_plane = vtkPlane()
    clip_plane.SetOrigin(0, 0.3, 0)
    clip_plane.SetNormal(0, -1, -1)

    clipper = vtkClipPolyData()
    clipper.SetInputConnection(subdivide.GetOutputPort())
    clipper.SetClipFunction(clip_plane)
    clipper.GenerateClippedOutputOn()

    cleaner = vtkCleanPolyData()
    cleaner.SetInputConnection(clipper.GetOutputPort())
    cleaner.SetTolerance(0.005)
    cleaner.Update()

    normals = vtkPolyDataNormals()
    normals.SetInputConnection(cleaner.GetOutputPort())
    normals.FlipNormalsOn()
    normals.SetFeatureAngle(60)

    # Now the tangents.
    tangents = vtkPolyDataTangents()
    tangents.SetInputConnection(normals.GetOutputPort())
    tangents.ComputeCellTangentsOn()
    tangents.ComputePointTangentsOff()
    tangents.Update()
    return tangents.GetOutput()
--
    t_coords = vtkFloatArray()
    t_coords.SetNumberOfComponents(2)
    t_coords.SetNumberOfTuples(num_pts)
    t_coords.SetName('Texture Coordinates')
    pt_id = 0
    u = u0
--
    colors = vtkNamedColors()

    slider = vtkSliderRepresentation2D()

    slider.SetMinimumValue(properties.minimum_value)
    slider.SetMaximumValue(properties.maximum_value)
    slider.SetValue(properties.initial_value)
    slider.SetTitleText(properties.title)
--
    slider_widget = vtkSliderWidget()
    slider_widget.SetRepresentation(slider)

    return slider_widget


--
            w2if = vtkWindowToImageFilter()
            w2if.SetInput(caller.GetRenderWindow())
            w2if.SetScale(self.image_quality, self.image_quality)
            if self.rgba:
                w2if.SetInputBufferTypeToRGBA()
            else:
--
                writer = vtkJPEGWriter()
            else:
                writer = vtkPNGWriter()
            writer.SetFileName(self.path)
            writer.SetInputData(w2if.GetOutput())
            writer.Write()
            print('Screenshot saved to:', self.path)

--
    colors = vtkNamedColors()
    # Set the background color.
    colors.SetColor('BkgColor', [26, 51, 102, 255])
    # colors.SetColor('BkgColor', [60, 93, 144, 255])

    ren1 = vtkRenderer()
    renWin = vtkRenderWindow()
    renWin.AddRenderer(ren1)

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(renWin)

    # Create the pipeline.
    #
    polyData = ReadPolyData(file_name)
--
    modelMapper = vtkPolyDataMapper()
    modelMapper.SetInputData(polyData)

    modelActor = vtkActor()
    modelActor.SetMapper(modelMapper)
    modelActor.GetProperty().SetDiffuseColor(colors.GetColor3d(actor_color))
    if actor_color != 'Wheat':
        modelActor.GetProperty().SetSpecular(0.6)
        modelActor.GetProperty().SetSpecularPower(30)
--
    modelAxesSource = vtkAxes()
    modelAxesSource.SetScaleFactor(10)
    modelAxesSource.SetOrigin(0, 0, 0)

    modelAxesMapper = vtkPolyDataMapper()
    modelAxesMapper.SetInputConnection(modelAxesSource.GetOutputPort())

    modelAxes = vtkActor()
    modelAxes.SetMapper(modelAxesMapper)

    ren1.AddActor(modelAxes)
    modelAxes.VisibilityOff()

--
                        help='If the color is Wheat then the vtk textbook colors are used.')
    args = parser.parse_args()
    return args.filename, args.figure, args.actor_color


def RotateX(renWin, actor):
--
        reader = vtkPLYReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtp':
        reader = vtkXMLPolyDataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.obj':
        reader = vtkOBJReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.stl':
        reader = vtkSTLReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtk':
        reader = vtkXMLPolyDataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.g':
        reader = vtkBYUReader()
        reader.SetGeometryFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    else:
        # Return a sphere if the extension is unknown.
        source = vtkSphereSource()
        source.Update()
        poly_data = source.GetOutput()
    return poly_data


--
        reader = vtkPLYReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtp':
        reader = vtkXMLpoly_dataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.obj':
        reader = vtkOBJReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.stl':
        reader = vtkSTLReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtk':
        reader = vtkpoly_dataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.g':
        reader = vtkBYUReader()
        reader.SetGeometryFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    else:
        # Return a None if the extension is unknown.
--
        source = vtkSphereSource()
        source.SetThetaResolution(100)
        source.SetPhiResolution(100)
        source.Update()
        polyData = source.GetOutput()

    colors = vtkNamedColors()
    colors.SetColor('HighNoonSun', [255, 255, 251, 255])  # Color temp. 5400°K
    colors.SetColor('100W Tungsten', [255, 214, 170, 255])  # Color temp. 2850°K

    renderer = vtkRenderer()
    renderer.SetBackground(colors.GetColor3d('Silver'))

    renderWindow = vtkRenderWindow()
    renderWindow.SetSize(640, 480)
    renderWindow.AddRenderer(renderer)

    interactor = vtkRenderWindowInteractor()
    interactor.SetRenderWindow(renderWindow)

    light1 = vtkLight()
    light1.SetFocalPoint(0, 0, 0)
    light1.SetPosition(0, 1, 0.2)
    light1.SetColor(colors.GetColor3d('HighNoonSun'))
    light1.SetIntensity(0.3)
    renderer.AddLight(light1)
--
    light2 = vtkLight()
    light2.SetFocalPoint(0, 0, 0)
    light2.SetPosition(1.0, 1.0, 1.0)
    light2.SetColor(colors.GetColor3d('100W Tungsten'))
    light2.SetIntensity(0.8)
    renderer.AddLight(light2)
--
    mapper = vtkPolyDataMapper()
    mapper.SetInputData(polyData)

    actor = vtkActor()
    actor.SetMapper(mapper)
    actor.GetProperty().SetAmbientColor(colors.GetColor3d('SaddleBrown'))
    actor.GetProperty().SetDiffuseColor(colors.GetColor3d('Sienna'))
    actor.GetProperty().SetSpecularColor(colors.GetColor3d('White'))
    actor.GetProperty().SetSpecular(0.51)
--
    plane = vtkCubeSource()
    plane.SetCenter((bounds[1] + bounds[0]) / 2.0,
                    bounds[2] - thickness / 2.0,
                    (bounds[5] + bounds[4]) / 2.0)
    plane.SetXLength(bounds[1] - bounds[0] + (rnge[0] * expand))
    plane.SetYLength(thickness)
--
    planeMapper = vtkPolyDataMapper()
    planeMapper.SetInputConnection(plane.GetOutputPort())

    planeActor = vtkActor()
    planeActor.SetMapper(planeMapper)
    renderer.AddActor(planeActor)

    renderWindow.SetMultiSamples(0)

    shadows = vtkShadowMapPass()

    seq = vtkSequencePass()

    passes = vtkRenderPassCollection()
    passes.AddItem(shadows.GetShadowMapBakerPass())
    passes.AddItem(shadows)
    seq.SetPasses(passes)

    cameraP = vtkCameraPass()
    cameraP.SetDelegatePass(seq)

    # Tell the renderer to use our render pass pipeline
    glrenderer = renderer
    glrenderer.SetPass(cameraP)
--
    colors = vtkNamedColors()

    fileName = get_program_parameters()

    renderer1 = vtkRenderer()
    renderer1.SetViewport(0.0, 0.0, 0.5, 1.0)

    renderer2 = vtkRenderer()
    renderer2.SetViewport(0.5, 0.0, 1.0, 1.0)

    renderWindow = vtkRenderWindow()
    renderWindow.AddRenderer(renderer1)
    renderWindow.AddRenderer(renderer2)
    renderWindow.SetWindowName('StripFran')

    interactor = vtkRenderWindowInteractor()
    interactor.SetRenderWindow(renderWindow)

    # Create a cyberware source.
    #
    cyber = vtkPolyDataReader()
    cyber.SetFileName(fileName)

    deci = vtkDecimatePro()
    deci.SetInputConnection(cyber.GetOutputPort())
    deci.SetTargetReduction(0.7)
    deci.PreserveTopologyOn()

    normals = vtkPolyDataNormals()
    normals.SetInputConnection(deci.GetOutputPort())

    mask = vtkMaskPolyData()
    mask.SetInputConnection(deci.GetOutputPort())
    mask.SetOnRatio(2)

    cyberMapper = vtkPolyDataMapper()
    cyberMapper.SetInputConnection(mask.GetOutputPort())

    cyberActor = vtkActor()
    cyberActor.SetMapper(cyberMapper)
    cyberActor.GetProperty().SetColor(colors.GetColor3d('Flesh'))

    stripper = vtkStripper()
    stripper.SetInputConnection(cyber.GetOutputPort())

    stripperMask = vtkMaskPolyData()
    stripperMask.SetInputConnection(stripper.GetOutputPort())
    stripperMask.SetOnRatio(2)

    stripperMapper = vtkPolyDataMapper()
    stripperMapper.SetInputConnection(stripperMask.GetOutputPort())

    stripperActor = vtkActor()
    stripperActor.SetMapper(stripperMapper)
    stripperActor.GetProperty().SetColor(colors.GetColor3d('Flesh'))

    # Add the actors to the renderer, set the background and size.
    #
--
    cam1 = vtkCamera()
    cam1.SetFocalPoint(0, 0, 0)
    cam1.SetPosition(1, 0, 0)
    cam1.SetViewUp(0, 1, 0)
    renderer1.SetActiveCamera(cam1)
    renderer2.SetActiveCamera(cam1)
--
    parser.add_argument('filename', help='fran_cut.vtk')
    args = parser.parse_args()
    return args.filename


if __name__ == '__main__':
--
    colors = vtkNamedColors()

    # Setup the render window, renderer, and interactor.
    renderer = vtkRenderer()
    renderWindow = vtkRenderWindow()
    renderWindow.AddRenderer(renderer)
    interactor = vtkRenderWindowInteractor()
    interactor.SetRenderWindow(renderWindow)

    # Read the data.

    # Create the pipeline.
--
    reader = vtkStructuredPointsReader()
    reader.SetFileName(vec_anim_paths[0])

    threshold = vtkThresholdPoints()
    threshold.SetInputConnection(reader.GetOutputPort())
    threshold.ThresholdByUpper(200)

    line = vtkLineSource()
    line.SetResolution(1)

    lines = vtkGlyph3D()
    lines.SetInputConnection(threshold.GetOutputPort())
    lines.SetSourceConnection(line.GetOutputPort())
    lines.SetScaleFactor(0.005)
    lines.SetScaleModeToScaleByScalar()
    lines.Update()
--
    vectorMapper = vtkPolyDataMapper()
    vectorMapper.SetInputConnection(lines.GetOutputPort())
    vectorMapper.SetScalarRange(lines.GetOutput().GetScalarRange())

    vectorActor = vtkActor()
    vectorActor.SetMapper(vectorMapper)
    vectorActor.GetProperty().SetOpacity(0.99)
    vectorActor.GetProperty().SetLineWidth(1.5)

    # Outline
    outline = vtkOutlineFilter()
    outline.SetInputConnection(reader.GetOutputPort())

    outlineMapper = vtkPolyDataMapper()
    outlineMapper.SetInputConnection(outline.GetOutputPort())

    outlineActor = vtkActor()
    outlineActor.SetMapper(outlineMapper)
    outlineActor.GetProperty().SetColor(colors.GetColor3d('Black'))

    #  Texture maps.
    textureMaps = list()
--
        tmap = vtkStructuredPointsReader()
        tmap.SetFileName(vec_anim_paths[i])

        texture = vtkTexture()
        texture.SetInputConnection(tmap.GetOutputPort())
        texture.InterpolateOff()
        texture.RepeatOff()
        textureMaps.append(texture)

--
    cam1 = vtkCamera()
    cam1.SetClippingRange(17.4043, 870.216)
    cam1.SetFocalPoint(136.71, 104.025, 23)
    cam1.SetPosition(204.747, 258.939, 63.7925)
    cam1.SetViewUp(-0.102647, -0.210897, 0.972104)
    cam1.Zoom(1.2)
--
    parser.add_argument('filename2', help='VectorAnimation/vecAnim1.vtk.')
    args = parser.parse_args()
    return args.filename1, args.filename2


if __name__ == '__main__':
--
    colors = vtkNamedColors()

    fileName = get_program_parameters()

    # hidden sphere
    sphere1 = vtkSphereSource()
    sphere1.SetRadius(0.5)

    innerMapper = vtkPolyDataMapper()
    innerMapper.SetInputConnection(sphere1.GetOutputPort())

    innerSphere = vtkActor()
    innerSphere.SetMapper(innerMapper)
    innerSphere.GetProperty().SetColor(colors.GetColor3d('BlanchedAlmond'))

    # sphere to texture
    sphere2 = vtkSphereSource()
    sphere2.SetRadius(1.0)
    sphere2.SetPhiResolution(21)
    sphere2.SetThetaResolution(21)

    pts = [0.0] * 6
    points = vtkPoints()
    points.SetNumberOfPoints(2)
    points.SetPoint(0, pts[:3])
    points.SetPoint(1, pts[3:])

    nrms = [0.0] * 6
--
    normals = vtkDoubleArray()
    normals.SetNumberOfComponents(3)
    normals.SetNumberOfTuples(2)
    normals.SetTuple(0, nrms[:3])
    normals.SetTuple(1, nrms[3:])

    planes = vtkPlanes()
    planes.SetPoints(points)
    planes.SetNormals(normals)

    tcoords = vtkImplicitTextureCoords()
    tcoords.SetInputConnection(sphere2.GetOutputPort())
    tcoords.SetRFunction(planes)

    outerMapper = vtkDataSetMapper()
    outerMapper.SetInputConnection(tcoords.GetOutputPort())

    tmap = vtkStructuredPointsReader()
    tmap.SetFileName(fileName)

    texture = vtkTexture()
    texture.SetInputConnection(tmap.GetOutputPort())
    texture.InterpolateOff()
    texture.RepeatOff()

    outerSphere = vtkActor()
    outerSphere.SetMapper(outerMapper)
    outerSphere.SetTexture(texture)
    outerSphere.GetProperty().SetColor(colors.GetColor3d('LightSalmon'))

    renWin = vtkRenderWindow()
    iren = vtkRenderWindowInteractor()
    aren = vtkRenderer()
    iren.SetRenderWindow(renWin)
    renWin.AddRenderer(aren)

    aren.AddActor(innerSphere)
    aren.AddActor(outerSphere)
--
    parser.add_argument('filename', help='texThres.vtk.')
    args = parser.parse_args()
    return args.filename


if __name__ == '__main__':
--
    description = 'Use a vtkClipDataSet to clip a vtkUnstructuredGrid..'
    epilogue = '''
 Use a vtkClipDataSet to clip a vtkUnstructuredGrid..
 The resulting output and clipped output are presented in yellow and red respectively.
 To illustrate the clipped interfaces, the example uses a vtkTransform to rotate each
    output about their centers.
--
    parser.add_argument('filename', help='treemesh.vtk')
    parser.add_argument('-o', action='store_false',
                        help='Output using the original code.')
    args = parser.parse_args()
    return args.filename, args.o

--
    reader = vtkUnstructuredGridReader()
    reader.SetFileName(filename)
    reader.Update()

    bounds = reader.GetOutput().GetBounds()
    center = reader.GetOutput().GetCenter()
--
    colors = vtkNamedColors()
    renderer = vtkRenderer()
    renderer.SetBackground(colors.GetColor3d('Wheat'))
    renderer.UseHiddenLineRemovalOn()

    renderWindow = vtkRenderWindow()
    renderWindow.AddRenderer(renderer)
    renderWindow.SetSize(640, 480)

    interactor = vtkRenderWindowInteractor()
    interactor.SetRenderWindow(renderWindow)

    xnorm = [-1.0, -1.0, 1.0]

    clipPlane = vtkPlane()
    clipPlane.SetOrigin(reader.GetOutput().GetCenter())
    clipPlane.SetNormal(xnorm)

    if correct_output:
        clipper = vtkClipDataSet()
        clipper.SetClipFunction(clipPlane)
        clipper.SetInputData(reader.GetOutput())
        clipper.SetValue(0.0)
        clipper.GenerateClippedOutputOff()
        clipper.Update()
--
        clipper1 = vtkClipDataSet()
        clipper1.SetClipFunction(clipPlane)
        clipper1.SetInputData(reader.GetOutput())
        clipper1.SetValue(0.0)
        clipper1.InsideOutOn()
        clipper1.GenerateClippedOutputOn()
--
        clipper = vtkClipDataSet()
        clipper.SetClipFunction(clipPlane)
        clipper.SetInputData(reader.GetOutput())
        clipper.SetValue(0.0)
        clipper.GenerateClippedOutputOn()
        clipper.Update()
--
    insideMapper = vtkDataSetMapper()
    insideMapper.SetInputData(clipper.GetOutput())
    insideMapper.ScalarVisibilityOff()

    insideActor = vtkActor()
    insideActor.SetMapper(insideMapper)
    insideActor.GetProperty().SetDiffuseColor(colors.GetColor3d('Banana'))
    insideActor.GetProperty().SetAmbient(0.3)
    insideActor.GetProperty().EdgeVisibilityOn()

    clippedMapper = vtkDataSetMapper()
    if correct_output:
        clippedMapper.SetInputData(clipper1.GetClippedOutput())
    else:
        clippedMapper.SetInputData(clipper.GetClippedOutput())
    clippedMapper.ScalarVisibilityOff()
--
    clippedActor = vtkActor()
    clippedActor.SetMapper(clippedMapper)
    clippedActor.GetProperty().SetDiffuseColor(colors.GetColor3d('tomato'))
    insideActor.GetProperty().SetAmbient(0.3)
    clippedActor.GetProperty().EdgeVisibilityOn()

--
    insideTransform = vtkTransform()
    insideTransform.Translate(-(bounds[1] - bounds[0]) * 0.75, 0, 0)
    insideTransform.Translate(center[0], center[1], center[2])
    insideTransform.RotateY(-120.0)
    insideTransform.Translate(-center[0], -center[1], -center[2])
    insideActor.SetUserTransform(insideTransform)
--
    clippedTransform = vtkTransform()
    clippedTransform.Translate((bounds[1] - bounds[0]) * 0.75, 0, 0)
    clippedTransform.Translate(center[0], center[1], center[2])
    if correct_output:
        clippedTransform.RotateY(60.0)
    else:
--
    description = 'Use a vtkTableBasedClipDataSet to clip a vtkUnstructuredGrid.'
    epilogue = '''
 Use a vtkTableBasedClipDataSet to clip a vtkUnstructuredGrid.
 The resulting output and clipped output are presented in yellow and red respectively.
 To illustrate the clipped interfaces, the example uses a vtkTransform to rotate each
    output about their centers.
--
    parser.add_argument('filename', help='treemesh.vtk')
    args = parser.parse_args()
    return args.filename


def main():
--
    reader = vtkUnstructuredGridReader()
    reader.SetFileName(filename)
    reader.Update()

    bounds = reader.GetOutput().GetBounds()
    center = reader.GetOutput().GetCenter()
--
    colors = vtkNamedColors()
    renderer = vtkRenderer()
    renderer.SetBackground(colors.GetColor3d('Wheat'))
    renderer.UseHiddenLineRemovalOn()

    renderWindow = vtkRenderWindow()
    renderWindow.AddRenderer(renderer)
    renderWindow.SetSize(640, 480)

    interactor = vtkRenderWindowInteractor()
    interactor.SetRenderWindow(renderWindow)

    xnorm = [-1.0, -1.0, 1.0]

    clipPlane = vtkPlane()
    clipPlane.SetOrigin(reader.GetOutput().GetCenter())
    clipPlane.SetNormal(xnorm)

    clipper = vtkTableBasedClipDataSet()
    clipper.SetClipFunction(clipPlane)
    clipper.SetInputData(reader.GetOutput())
    clipper.SetValue(0.0)
    clipper.GenerateClippedOutputOn()
    clipper.Update()
--
    insideMapper = vtkDataSetMapper()
    insideMapper.SetInputData(clipper.GetOutput())
    insideMapper.ScalarVisibilityOff()

    insideActor = vtkActor()
    insideActor.SetMapper(insideMapper)
    insideActor.GetProperty().SetDiffuseColor(colors.GetColor3d('Banana'))
    insideActor.GetProperty().SetAmbient(0.3)
    insideActor.GetProperty().EdgeVisibilityOn()

    clippedMapper = vtkDataSetMapper()
    clippedMapper.SetInputData(clipper.GetClippedOutput())
    clippedMapper.ScalarVisibilityOff()

    clippedActor = vtkActor()
    clippedActor.SetMapper(clippedMapper)
    clippedActor.GetProperty().SetDiffuseColor(colors.GetColor3d('Tomato'))
    insideActor.GetProperty().SetAmbient(0.3)
    clippedActor.GetProperty().EdgeVisibilityOn()

--
    insideTransform = vtkTransform()
    insideTransform.Translate(-(bounds[1] - bounds[0]) * 0.75, 0, 0)
    insideTransform.Translate(center[0], center[1], center[2])
    insideTransform.RotateY(-120.0)
    insideTransform.Translate(-center[0], -center[1], -center[2])
    insideActor.SetUserTransform(insideTransform)
--
    clippedTransform = vtkTransform()
    clippedTransform.Translate((bounds[1] - bounds[0]) * 0.75, 0, 0)
    clippedTransform.Translate(center[0], center[1], center[2])
    clippedTransform.RotateY(60.0)
    clippedTransform.Translate(-center[0], -center[1], -center[2])
    clippedActor.SetUserTransform(clippedTransform)
--
    colors = vtkNamedColors()

    polyData = ReadPolyData(pd_fn)
    mapper = vtkPolyDataMapper()
    mapper.SetInputData(polyData)

    actor = vtkActor()
    actor.SetMapper(mapper)
    actor.GetProperty().SetDiffuseColor(colors.GetColor3d('Crimson'))
    actor.GetProperty().SetSpecular(.6)
    actor.GetProperty().SetSpecularPower(30)

    renderer = vtkRenderer()
    renderWindow = vtkRenderWindow()
    renderWindow.AddRenderer(renderer)
    renderWindow.SetWindowName('SaveSceneToFieldData')

    renderWindowInteractor = vtkRenderWindowInteractor()
    renderWindowInteractor.SetRenderWindow(renderWindow)

    renderer.AddActor(actor)
    renderer.SetBackground(colors.GetColor3d('Silver'))

--
        reader = vtkPLYReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtp':
        reader = vtkXMLpoly_dataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.obj':
        reader = vtkOBJReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.stl':
        reader = vtkSTLReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtk':
        reader = vtkpoly_dataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.g':
        reader = vtkBYUReader()
        reader.SetGeometryFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    else:
        # Return a None if the extension is unknown.
--
    cameraArray = vtkStringArray()
    cameraArray.SetNumberOfValues(1)
    cameraArray.SetValue(0, buffer)
    cameraArray.SetName('Camera')
    data.GetFieldData().AddArray(cameraArray)

--
    colors = vtkNamedColors()

    polyData = ReadPolyData(pd_fn)
    mapper = vtkPolyDataMapper()
    mapper.SetInputData(polyData)

    actor = vtkActor()
    actor.SetMapper(mapper)
    actor.GetProperty().SetDiffuseColor(colors.GetColor3d('Crimson'))
    actor.GetProperty().SetSpecular(.6)
    actor.GetProperty().SetSpecularPower(30)

    renderer = vtkRenderer()
    renderWindow = vtkRenderWindow()
    renderWindow.AddRenderer(renderer)
    renderWindow.SetWindowName('SaveSceneToFile')

    renderWindowInteractor = vtkRenderWindowInteractor()
    renderWindowInteractor.SetRenderWindow(renderWindow)

    renderer.AddActor(actor)
    renderer.SetBackground(colors.GetColor3d('Silver'))

--
        reader = vtkPLYReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtp':
        reader = vtkXMLpoly_dataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.obj':
        reader = vtkOBJReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.stl':
        reader = vtkSTLReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.vtk':
        reader = vtkpoly_dataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == '.g':
        reader = vtkBYUReader()
        reader.SetGeometryFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    else:
        # Return a None if the extension is unknown.
--
                        default='https://raw.githubusercontent.com/Kitware/vtk-examples/gh-pages/src/Coverage/vtk_vtk-examples_xref.json',
                        help='The URL for the JSON cross-reference file.')
    parser.add_argument('-o', '--overwrite', action="store_true",
                        help='Force an initial download of the JSON cross-reference file.')

    args = parser.parse_args()
--
        kv = d[vtk_class][lang].items()
    except KeyError:
        return None, None
    if len(kv) > number:
        if all_values:
            samples = list(kv)
--
    total_number, examples = get_examples(xref_dict, vtk_class, language, all_values=all_values, number=number,
                                          md_fmt=md)
    if examples:
        if total_number <= number or all_values:
            print(f'VTK Class: {vtk_class}, language: {language}\n'
                  f'Number of example(s): {total_number}.')
--
v = vtkVariant()
print(f"Invalid variant: {repr(v)}, '{v.GetTypeAsString()}'")

# Copy constructor
v = vtkVariant(vtkVariant("variant"))
print(f"Copied variant: {repr(v)}, '{v.GetTypeAsString()}'")

# Conversion constructors
v = vtkVariant(1)
print(f"Integer variant: {repr(v)}, '{v.GetTypeAsString()}'")
v = vtkVariant(1.0)
print(f"Float variant: {repr(v)}, '{v.GetTypeAsString()}'")
v = vtkVariant("hello")
print(f"String variant: {repr(v)}, '{v.GetTypeAsString()}'")
v = vtkVariant(unicodeEtre)
print(f"Unicode variant: {repr(v)}, '{v.GetTypeAsString()}'")
v = vtkVariant(vtkStringArray())
print(f"Object variant: {repr(v)}, '{v.GetTypeAsString()}'")

# Explicit type constructor
v1 = vtkVariant(1, VTK_UNSIGNED_SHORT)
v2 = vtkVariant(2, v1.GetType())
print(f"UShort variant: {repr(v1)}, '{v1.GetTypeAsString()}'")

# Type checking
if v2.IsUnsignedShort():
    print("v2 is UnsignedShort")
--
a = vtkVariantArray()
a.InsertNextValue(vtkVariant())
a.InsertNextValue(1)
a.InsertNextValue(2.0)
a.InsertNextValue("hello")
a.InsertNextValue(unicodeEtre)
--
if v2 == vtkVariant(2):
    print("v2 is equal to 2")
if v2 > vtkVariant(1):
    print("v2 is greater than 1")
if v2 < vtkVariant(3):
    print("v2 is less than 3")
if v2 == vtkVariant("2"):
    print("v2 is equal to '2'")

# Use as a dict key (hashed as a string)
d = {vtkVariant(1): 0, vtkVariant('1'): 1, vtkVariant(): 3}
print("Index is %i" % d[vtkVariant(1.0)])

#
# Extra functionality from vtk.util.vtkVariant
#
--
v = vtkVariantCreate(1, 'unsigned int')

# Value extraction
v = vtkVariant(6.0)
f = vtkVariantExtract(v)

# Value extraction with type specified
f = vtkVariantExtract(v, 'double')

# Casting a variant
v = vtkVariant("10")
i = vtkVariantCast(v, 'int')
print(f"Valid cast result: {repr(i)}")

# A failed cast returns None
v = vtkVariant("hello")
i = vtkVariantCast(v, 'int')
print(f"Invalid cast result: {repr(i)}")

#
# Comparisons and sorting: See VTK docs for more info
#
--
v1 = vtkVariant(10)
v2 = vtkVariant("10")
r = vtkVariantStrictWeakOrder(v1, v2)
print("Strict weak order (10, '10') ->", r)

# Sorting by strict weak order, using a key function:
unsorted = [1, 2.5, vtkVariant(), "0", unicodeEtre]
l = [vtkVariant(x) for x in unsorted]
l.sort(key=vtkVariantStrictWeakOrderKey)
print("Sort by weak order ->", l)

# Check two variants for strict equality of type and value.
b = vtkVariantStrictEquality(v1, v2)
print(f"Strict equality (10, '10') -> {b}")

# Two special-purpose methods.
# First is identical to (v1 < v2)
b = vtkVariantLessThan(v1, v2)
# Second is identical to (v1 == v2)
b = vtkVariantEqual(v1, v2)
--
        additional_modules = ['vtkInteractionStyle', 'vtkRenderingFreeType',
                              'vtkRenderingContextOpenGL2', 'vtkRenderingOpenGL2', 'vtkRenderingVolumeOpenGL2',
                              'vtkRenderingUI']
        comments = [
            '',
            '# You may need to uncomment one or more of the following imports.',
--
    use_json = not vtk_version_ok(9, 0, 20210918)
    if use_json:
        if not json_path:
            print('modules.json (from your VTK build directory) is needed.')
            return
        jpath = Path(json_path)
--
        vtklib = importlib.__import__('vtkmodules')
        vtk_modules = sorted(vtklib.__all__)

    name_to_module = dict()
    for module in vtk_modules:
        try:
            module_dict = importlib.import_module('vtkmodules.' + module).__dict__
            for name in module_dict:
                name_to_module[name] = module
        except ModuleNotFoundError:
            # print(module, ' not found.')
            continue
--
                module = name_to_module[vtk_class]
                imports[name][module].add(vtk_class)

    res = format_imports(imports)
    if ofn:
        path = Path(ofn)
--
    ver = vtkVersion()
    actual_version = (100 * ver.GetVTKMajorVersion() + ver.GetVTKMinorVersion()) \
                     * 100000000 + ver.GetVTKBuildVersion()
    if actual_version >= requested_version:
        return True
    else:
--
    vtk_include_pattern = re.compile(r'^(vtk\S+)')
    vtk_qt_include_pattern = re.compile(r'^(QVTK\S+)')


def get_headers_modules(json_data):
    """
--
                    m = Patterns.vtk_include_pattern.match(header_parts[1])
                    if m:
                        headers[m.group(1)].add(path)
                        continue
                    m = Patterns.vtk_qt_include_pattern.match(header_parts[1])
                    if m:
                        headers[m.group(1)].add(path)
    for incl in headers:
        if incl in vtk_headers_modules:
            m = vtk_headers_modules[incl]
            for v in m:
                modules.add(v)
        else:
            inc_no_mod.add(incl)
            inc_no_mod_headers[incl] = headers[incl]
--
    modules, mod_implements, inc_no_mod, inc_no_mod_headers = get_vtk_components(jpath, paths)

    res = '\n'.join(disp_components(modules, mod_implements))
    if inc_no_mod:
        res += '\n'.join(disp_missing_components(inc_no_mod, inc_no_mod_headers))

--
    colors = vtkNamedColors()

    # We begin by creating the data we want to render.
    # For this tutorial, we create a 3D-image containing three overlaping cubes.
    # This data can of course easily be replaced by data from a medical CT-scan or anything else three dimensional.
    # The only limit is that the data must be reduced to unsigned 8 bit or 16 bit integers.
--
    dataImporter = vtkImageImport()
    # The previously created array is converted to a string of chars and imported.
    data_string = data_matrix.tobytes()
    dataImporter.CopyImportVoidPointer(data_string, len(data_string))
    # The type of the newly imported data is set to unsigned char (uint8)
    dataImporter.SetDataScalarTypeToUnsignedChar()
--
    alphaChannelFunc = vtkPiecewiseFunction()
    alphaChannelFunc.AddPoint(0, 0.0)
    alphaChannelFunc.AddPoint(50, 0.05)
    alphaChannelFunc.AddPoint(100, 0.1)
    alphaChannelFunc.AddPoint(150, 0.2)

--
    colorFunc = vtkColorTransferFunction()
    colorFunc.AddRGBPoint(50, 1.0, 0.0, 0.0)
    colorFunc.AddRGBPoint(100, 0.0, 1.0, 0.0)
    colorFunc.AddRGBPoint(150, 0.0, 0.0, 1.0)

    # The previous two classes stored properties.
--
    volumeProperty = vtkVolumeProperty()
    volumeProperty.SetColor(colorFunc)
    volumeProperty.SetScalarOpacity(alphaChannelFunc)

    volumeMapper = vtkFixedPointVolumeRayCastMapper()
    volumeMapper.SetInputConnection(dataImporter.GetOutputPort())

    # The class vtkVolume is used to pair the previously declared volume as well as the properties
    #  to be used when rendering that volume.
    volume = vtkVolume()
    volume.SetMapper(volumeMapper)
    volume.SetProperty(volumeProperty)

    # With almost everything else ready, its time to initialize the renderer and window, as well as
    #  creating a method for exiting the application
    renderer = vtkRenderer()
    renderWin = vtkRenderWindow()
    renderWin.AddRenderer(renderer)
    renderInteractor = vtkRenderWindowInteractor()
    renderInteractor.SetRenderWindow(renderWin)

    # We add the volume to the renderer ...
    renderer.AddVolume(volume)
    renderer.SetBackground(colors.GetColor3d("MistyRose"))
--
    colors = vtkNamedColors()

    ren1 = vtkRenderer()

    renWin = vtkRenderWindow()
    renWin.AddRenderer(ren1)

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(renWin)

    # Create the pipeline.
    #
    reader = vtkStructuredPointsReader()
    reader.SetFileName(fileName)

    psource = vtkPointSource()
    psource.SetNumberOfPoints(25)
    psource.SetCenter(133.1, 116.3, 5.0)
    psource.SetRadius(2.0)

    threshold = vtkThresholdPoints()
    threshold.SetInputConnection(reader.GetOutputPort())
    threshold.ThresholdByUpper(275)

    streamers = vtkStreamTracer()
    streamers.SetInputConnection(reader.GetOutputPort())
    streamers.SetSourceConnection(psource.GetOutputPort())
    # streamers.SetMaximumPropagationUnitToTimeUnit()
    streamers.SetMaximumPropagation(100.0)
    # streamers.SetInitialIntegrationStepUnitToCellLengthUnit()
--
    tubes = vtkTubeFilter()
    tubes.SetInputConnection(streamers.GetOutputPort())
    tubes.SetRadius(0.3)
    tubes.SetNumberOfSides(6)
    tubes.SetVaryRadius(0)

    lut = vtkLookupTable()
    lut.SetHueRange(.667, 0.0)
    lut.Build()

    streamerMapper = vtkPolyDataMapper()
    streamerMapper.SetInputConnection(tubes.GetOutputPort())
    streamerMapper.SetScalarRange(scalarRange[0], scalarRange[1])
    streamerMapper.SetLookupTable(lut)

    streamerActor = vtkActor()
    streamerActor.SetMapper(streamerMapper)

    # Speed contours.
    iso = vtkContourFilter()
    iso.SetInputConnection(reader.GetOutputPort())
    iso.SetValue(0, 175)

    isoMapper = vtkPolyDataMapper()
    isoMapper.SetInputConnection(iso.GetOutputPort())
    isoMapper.ScalarVisibilityOff()

    isoActor = vtkActor()
    isoActor.SetMapper(isoMapper)
    isoActor.GetProperty().SetRepresentationToWireframe()
    isoActor.GetProperty().SetOpacity(0.25)

    # Outline
    outline = vtkOutlineFilter()
    outline.SetInputConnection(reader.GetOutputPort())

    outlineMapper = vtkPolyDataMapper()
    outlineMapper.SetInputConnection(outline.GetOutputPort())

    outlineActor = vtkActor()
    outlineActor.SetMapper(outlineMapper)
    outlineActor.GetProperty().SetColor(colors.GetColor3d("Black"))

    # Add the actors to the renderer, set the background and size.
    #
--
    cam1 = vtkCamera()
    cam1.SetClippingRange(17.4043, 870.216)
    cam1.SetFocalPoint(136.71, 104.025, 23)
    cam1.SetPosition(204.747, 258.939, 63.7925)
    cam1.SetViewUp(-0.102647, -0.210897, 0.972104)
    cam1.Zoom(1.2)
--
    parser.add_argument('filename', help='carotid.vtk')
    args = parser.parse_args()
    return args.filename


if __name__ == '__main__':
--
    colors = vtkNamedColors()

    fileName1, fileName2 = get_program_parameters()

    # This example shows how to use decimation to reduce a polygonal mesh. We also
    # use mesh smoothing and generate surface normals to give a pleasing result.
--
    fran = vtkPolyDataReader()
    fran.SetFileName(fileName1)

    # Read the corresponding texture.
    textureReader = vtkPNGReader()
    textureReader.SetFileName(fileName2)

    texture = vtkTexture()
    texture.InterpolateOn()
    texture.SetInputConnection(textureReader.GetOutputPort())

    # We want to preserve topology (not let any cracks form). This may limit
    # the total reduction possible, which we have specified at 90%.
--
    deci = vtkDecimatePro()
    deci.SetInputConnection(fran.GetOutputPort())
    deci.SetTargetReduction(0.9)
    deci.PreserveTopologyOn()

    decimatedNormals = vtkPolyDataNormals()
    decimatedNormals.SetInputConnection(deci.GetOutputPort())
    decimatedNormals.FlipNormalsOn()
    decimatedNormals.SetFeatureAngle(60)

    originalNormals = vtkPolyDataNormals()
    originalNormals.SetInputConnection(fran.GetOutputPort())
    originalNormals.FlipNormalsOn()
    originalNormals.SetFeatureAngle(60)

    decimatedMapper = vtkPolyDataMapper()
    decimatedMapper.SetInputConnection(decimatedNormals.GetOutputPort())

    decimatedActor = vtkActor()
    decimatedActor.SetMapper(decimatedMapper)
    decimatedActor.GetProperty().SetAmbient(.5)
    decimatedActor.GetProperty().SetDiffuse(.5)
    decimatedActor.SetTexture(texture)

    originalMapper = vtkPolyDataMapper()
    originalMapper.SetInputConnection(originalNormals.GetOutputPort())

    originalActor = vtkActor()
    originalActor.SetMapper(originalMapper)
    originalActor.GetProperty().SetAmbient(.5)
    originalActor.GetProperty().SetDiffuse(.5)
    originalActor.SetTexture(texture)

--
    renderer1 = vtkRenderer()
    renderer1.SetViewport(0.0, 0.0, 0.5, 1.0)

    renderer2 = vtkRenderer()
    renderer2.SetViewport(0.5, 0.0, 1.0, 1.0)

    renderWindow = vtkRenderWindow()
    renderWindow.AddRenderer(renderer1)
    renderWindow.AddRenderer(renderer2)
    renderWindow.SetWindowName('DecimateFran')

    interactor = vtkRenderWindowInteractor()
    interactor.SetRenderWindow(renderWindow)

    # Add the actors to the renderer, set the background and size.
    #
    renderer1.AddActor(originalActor)
--
    cam1 = vtkCamera()
    cam1.SetClippingRange(0.0475572, 2.37786)
    cam1.SetFocalPoint(0.052665, -0.129454, -0.0573973)
    cam1.SetPosition(0.327637, -0.116299, -0.256418)
    cam1.SetViewUp(-0.0225386, 0.999137, 0.034901)
    renderer1.SetActiveCamera(cam1)
--
    parser.add_argument('filename1', help='fran_cut.vtk')
    parser.add_argument('filename2', help='fran_cut.png.')
    args = parser.parse_args()
    return args.filename1, args.filename2


--
    colors = vtkNamedColors()

    fileName = get_program_parameters()

    # This example shows how to use decimation to reduce a polygonal mesh. We also
    # use mesh smoothing and generate surface normals to give a pleasing result.
--
    hawaii = vtkPolyDataReader()
    hawaii.SetFileName(fileName)

    # We want to preserve topology (not let any cracks form). This may limit
    # the total reduction possible, which we have specified at 90%.
    #
    deci = vtkDecimatePro()
    deci.SetInputConnection(hawaii.GetOutputPort())
    deci.SetTargetReduction(0.9)
    deci.PreserveTopologyOn()

    decimatedNormals = vtkPolyDataNormals()
    decimatedNormals.SetInputConnection(deci.GetOutputPort())
    decimatedNormals.FlipNormalsOn()
    decimatedNormals.SetFeatureAngle(60)

    decimatedMapper = vtkPolyDataMapper()
    decimatedMapper.SetInputConnection(decimatedNormals.GetOutputPort())

    decimatedActor = vtkActor()
    decimatedActor.SetMapper(decimatedMapper)
    decimatedActor.GetProperty().SetColor(colors.GetColor3d('Sienna'))
    decimatedActor.GetProperty().SetRepresentationToWireframe()

    originalMapper = vtkPolyDataMapper()
    originalMapper.SetInputConnection(decimatedNormals.GetOutputPort())

    originalActor = vtkActor()
    originalActor.SetMapper(originalMapper)
    originalActor.GetProperty().SetColor(colors.GetColor3d('Sienna'))

    # Create the RenderWindow, Renderer and Interactor.
    #
    renderer1 = vtkRenderer()
    renderer1.SetViewport(0.0, 0.0, 0.5, 1.0)

    renderer2 = vtkRenderer()
    renderer2.SetViewport(0.5, 0.0, 1.0, 1.0)

    renderWindow = vtkRenderWindow()
    renderWindow.AddRenderer(renderer1)
    renderWindow.AddRenderer(renderer2)

    interactor = vtkRenderWindowInteractor()
    interactor.SetRenderWindow(renderWindow)

    # Add the actors to the renderer, set the background and size.
    #
    renderer1.AddActor(originalActor)
--
    cam1 = vtkCamera()
    renderer1.SetActiveCamera(cam1)
    renderer2.SetActiveCamera(cam1)
    renderer1.ResetCamera()
    cam1.Elevation(-30)
    cam1.Dolly(1.2)
--
    parser.add_argument('filename1', help='honolulu.vtk')
    args = parser.parse_args()
    return args.filename1


if __name__ == '__main__':
--
    colors = vtkNamedColors()

    # Read a vtk file
    #
    plate = vtkPolyDataReader()
    plate.SetFileName(file_name)
    plate.SetVectorsName("mode8")
    plate.Update()

    warp = vtkWarpVector()
    warp.SetInputConnection(plate.GetOutputPort())
    warp.SetScaleFactor(0.5)

    normals = vtkPolyDataNormals()
    normals.SetInputConnection(warp.GetOutputPort())

    color = vtkVectorDot()
    color.SetInputConnection(normals.GetOutputPort())

    lut = vtkLookupTable()
    MakeLUT(color_scheme, lut)

    plateMapper = vtkDataSetMapper()
    plateMapper.SetInputConnection(color.GetOutputPort())
    plateMapper.SetLookupTable(lut)
    plateMapper.SetScalarRange(-1, 1)

    plateActor = vtkActor()
    plateActor.SetMapper(plateMapper)

    # Create the RenderWindow, Renderer and both Actors
    #
    ren = vtkRenderer()
    renWin = vtkRenderWindow()
    renWin.AddRenderer(ren)

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(renWin)

    # Add the actors to the renderer, set the background and size
    #
    ren.AddActor(plateActor)
--
    parser.add_argument('filename', help='plate.vtk')
    parser.add_argument('color_scheme', default=0, type=int, nargs='?', help='The particular color scheme to use.')
    args = parser.parse_args()
    return args.filename, args.color_scheme


--
    ctf = vtkColorTransferFunction()

    if colorScheme == 1:
        # Green to purple diverging.
        ctf.SetColorSpaceToDiverging()
        ctf.AddRGBPoint(0.0, 0.085, 0.532, 0.201)
--
    colors = vtkNamedColors()

    # Create lines which serve as the 'seed' geometry. The lines spell the
    # word 'hello'.
    #
    reader = vtkPolyDataReader()
    reader.SetFileName(fileName)

    lineMapper = vtkPolyDataMapper()
    lineMapper.SetInputConnection(reader.GetOutputPort())

    lineActor = vtkActor()
    lineActor.SetMapper(lineMapper)
    lineActor.GetProperty().SetColor(colors.GetColor3d('Tomato'))
    lineActor.GetProperty().SetLineWidth(3.0)

    # Create implicit model with vtkImplicitModeller. This computes a scalar
--
    imp = vtkImplicitModeller()
    imp.SetInputConnection(reader.GetOutputPort())
    imp.SetSampleDimensions(110, 40, 20)
    imp.SetMaximumDistance(0.25)
    imp.SetModelBounds(-1.0, 10.0, -1.0, 3.0, -1.0, 1.0)

    contour = vtkContourFilter()
    contour.SetInputConnection(imp.GetOutputPort())
    contour.SetValue(0, 0.25)

    impMapper = vtkPolyDataMapper()
    impMapper.SetInputConnection(contour.GetOutputPort())
    impMapper.ScalarVisibilityOff()

    impActor = vtkActor()
    impActor.SetMapper(impMapper)
    impActor.GetProperty().SetColor(colors.GetColor3d('Peacock'))
    impActor.GetProperty().SetOpacity(0.5)

    # Create the usual graphics stuff.
--
    ren1 = vtkRenderer()

    renWin = vtkRenderWindow()
    renWin.AddRenderer(ren1)
    renWin.SetWindowName('Hello')

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(renWin)

    # Add the actors to the renderer, set the background and size
    #
    ren1.AddActor(lineActor)
--
    camera = vtkCamera()
    camera.SetFocalPoint(4.5, 1, 0)
    camera.SetPosition(4.5, 1.0, 6.73257)
    camera.SetViewUp(0, 1, 0)

    ren1.SetActiveCamera(camera)
--
    parser.add_argument('filename', help='hello.vtk')
    args = parser.parse_args()
    return args.filename


if __name__ == '__main__':
--
    colors = vtkNamedColors()

    # Create the RenderWindow, Renderer and Interactor.
    ren1 = vtkRenderer()
    renWin = vtkRenderWindow()
    renWin.AddRenderer(ren1)
    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(renWin)

    # Create the pipeline.
    reader = vtkStructuredPointsReader()
    reader.SetFileName(fileName)

    iso = vtkContourFilter()
    iso.SetInputConnection(reader.GetOutputPort())
    iso.SetValue(0, 128)

    isoMapper = vtkPolyDataMapper()
    isoMapper.SetInputConnection(iso.GetOutputPort())
    isoMapper.ScalarVisibilityOff()

    isoActor = vtkActor()
    isoActor.SetMapper(isoMapper)
    isoActor.GetProperty().SetColor(colors.GetColor3d("Banana"))

    outline = vtkOutlineFilter()
    outline.SetInputConnection(reader.GetOutputPort())

    outlineMapper = vtkPolyDataMapper()
    outlineMapper.SetInputConnection(outline.GetOutputPort())

    outlineActor = vtkActor()
    outlineActor.SetMapper(outlineMapper)

    # Add the actors to the renderer, set the background and size.
    #
    ren1.AddActor(outlineActor)
--
    parser.add_argument('filename', help='ironProt.vtk')
    args = parser.parse_args()
    return args.filename


if __name__ == '__main__':
--
    colors = vtkNamedColors()

    textureFile, motorFile = get_program_parameters()

    # Create the Renderer, RenderWindow and RenderWindowInteractor.
    ren = vtkRenderer()
    renWin = vtkRenderWindow()
    renWin.AddRenderer(ren)
    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(renWin)

    # Create the cutting planes.
    planes = vtkPlanes()
    points = vtkPoints()
    norms = vtkFloatArray()

    norms.SetNumberOfComponents(3)
    points.InsertPoint(0, 0.0, 0.0, 0.0)
    norms.InsertTuple3(0, 0.0, 0.0, 1.0)
    points.InsertPoint(1, 0.0, 0.0, 0.0)
--
    texReader = vtkStructuredPointsReader()
    texReader.SetFileName(textureFile)
    texture = vtkTexture()
    texture.SetInputConnection(texReader.GetOutputPort())
    texture.InterpolateOff()
    texture.RepeatOff()

    # Set up the pipelines for the parts of the motor.
--
    camera = vtkCamera()
    camera.SetFocalPoint(0.0286334, 0.0362996, 0.0379685)
    camera.SetPosition(1.37067, 1.08629, -1.30349)
    camera.SetViewAngle(17.673)
    camera.SetClippingRange(1, 10)
    camera.SetViewUp(-0.376306, -0.5085, -0.774482)
--
    parser.add_argument('textureFile', help='The texture file: texThres2.vtk')
    parser.add_argument('motorFile', help='The motor file: motor.g.')
    args = parser.parse_args()
    return args.textureFile, args.motorFile


--
    colors = vtkNamedColors()
    # Set the furniture colors, matching those in the VTKTextBook.
    tableTopColor = [0.59, 0.427, 0.392]
    filingCabinetColor = [0.8, 0.8, 0.6]
    bookShelfColor = [0.8, 0.8, 0.6]
    windowColor = [0.3, 0.3, 0.5]
--
    reader = vtkDataSetReader()
    reader.SetFileName(fileName)

    # Create the scene.
    # We generate a whole bunch of planes which correspond to
    # the geometry in the analysis; tables, bookshelves and so on.
    table1 = vtkStructuredGridGeometryFilter()
    table1.SetInputData(reader.GetStructuredGridOutput())
    table1.SetExtent(11, 15, 7, 9, 8, 8)
    mapTable1 = vtkPolyDataMapper()
    mapTable1.SetInputConnection(table1.GetOutputPort())
    mapTable1.ScalarVisibilityOff()
    table1Actor = vtkActor()
    table1Actor.SetMapper(mapTable1)
    table1Actor.GetProperty().SetColor(colors.GetColor3d('TableTop'))

    table2 = vtkStructuredGridGeometryFilter()
    table2.SetInputData(reader.GetStructuredGridOutput())
    table2.SetExtent(11, 15, 10, 12, 8, 8)
    mapTable2 = vtkPolyDataMapper()
    mapTable2.SetInputConnection(table2.GetOutputPort())
    mapTable2.ScalarVisibilityOff()
    table2Actor = vtkActor()
    table2Actor.SetMapper(mapTable2)
    table2Actor.GetProperty().SetColor(colors.GetColor3d('TableTop'))

    FilingCabinet1 = vtkStructuredGridGeometryFilter()
    FilingCabinet1.SetInputData(reader.GetStructuredGridOutput())
    FilingCabinet1.SetExtent(15, 15, 7, 9, 0, 8)
    mapFilingCabinet1 = vtkPolyDataMapper()
    mapFilingCabinet1.SetInputConnection(FilingCabinet1.GetOutputPort())
    mapFilingCabinet1.ScalarVisibilityOff()
    FilingCabinet1Actor = vtkActor()
    FilingCabinet1Actor.SetMapper(mapFilingCabinet1)
    FilingCabinet1Actor.GetProperty().SetColor(colors.GetColor3d('FilingCabinet'))

    FilingCabinet2 = vtkStructuredGridGeometryFilter()
    FilingCabinet2.SetInputData(reader.GetStructuredGridOutput())
    FilingCabinet2.SetExtent(15, 15, 10, 12, 0, 8)
    mapFilingCabinet2 = vtkPolyDataMapper()
    mapFilingCabinet2.SetInputConnection(FilingCabinet2.GetOutputPort())
    mapFilingCabinet2.ScalarVisibilityOff()
    FilingCabinet2Actor = vtkActor()
    FilingCabinet2Actor.SetMapper(mapFilingCabinet2)
    FilingCabinet2Actor.GetProperty().SetColor(colors.GetColor3d('FilingCabinet'))

    bookshelf1Top = vtkStructuredGridGeometryFilter()
    bookshelf1Top.SetInputData(reader.GetStructuredGridOutput())
    bookshelf1Top.SetExtent(13, 13, 0, 4, 0, 11)
    mapBookshelf1Top = vtkPolyDataMapper()
    mapBookshelf1Top.SetInputConnection(bookshelf1Top.GetOutputPort())
    mapBookshelf1Top.ScalarVisibilityOff()
    bookshelf1TopActor = vtkActor()
    bookshelf1TopActor.SetMapper(mapBookshelf1Top)
    bookshelf1TopActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf1Bottom = vtkStructuredGridGeometryFilter()
    bookshelf1Bottom.SetInputData(reader.GetStructuredGridOutput())
    bookshelf1Bottom.SetExtent(20, 20, 0, 4, 0, 11)
    mapBookshelf1Bottom = vtkPolyDataMapper()
    mapBookshelf1Bottom.SetInputConnection(bookshelf1Bottom.GetOutputPort())
    mapBookshelf1Bottom.ScalarVisibilityOff()
    bookshelf1BottomActor = vtkActor()
    bookshelf1BottomActor.SetMapper(mapBookshelf1Bottom)
    bookshelf1BottomActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf1Front = vtkStructuredGridGeometryFilter()
    bookshelf1Front.SetInputData(reader.GetStructuredGridOutput())
    bookshelf1Front.SetExtent(13, 20, 0, 0, 0, 11)
    mapBookshelf1Front = vtkPolyDataMapper()
    mapBookshelf1Front.SetInputConnection(bookshelf1Front.GetOutputPort())
    mapBookshelf1Front.ScalarVisibilityOff()
    bookshelf1FrontActor = vtkActor()
    bookshelf1FrontActor.SetMapper(mapBookshelf1Front)
    bookshelf1FrontActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf1Back = vtkStructuredGridGeometryFilter()
    bookshelf1Back.SetInputData(reader.GetStructuredGridOutput())
    bookshelf1Back.SetExtent(13, 20, 4, 4, 0, 11)
    mapBookshelf1Back = vtkPolyDataMapper()
    mapBookshelf1Back.SetInputConnection(bookshelf1Back.GetOutputPort())
    mapBookshelf1Back.ScalarVisibilityOff()
    bookshelf1BackActor = vtkActor()
    bookshelf1BackActor.SetMapper(mapBookshelf1Back)
    bookshelf1BackActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf1LHS = vtkStructuredGridGeometryFilter()
    bookshelf1LHS.SetInputData(reader.GetStructuredGridOutput())
    bookshelf1LHS.SetExtent(13, 20, 0, 4, 0, 0)
    mapBookshelf1LHS = vtkPolyDataMapper()
    mapBookshelf1LHS.SetInputConnection(bookshelf1LHS.GetOutputPort())
    mapBookshelf1LHS.ScalarVisibilityOff()
    bookshelf1LHSActor = vtkActor()
    bookshelf1LHSActor.SetMapper(mapBookshelf1LHS)
    bookshelf1LHSActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf1RHS = vtkStructuredGridGeometryFilter()
    bookshelf1RHS.SetInputData(reader.GetStructuredGridOutput())
    bookshelf1RHS.SetExtent(13, 20, 0, 4, 11, 11)
    mapBookshelf1RHS = vtkPolyDataMapper()
    mapBookshelf1RHS.SetInputConnection(bookshelf1RHS.GetOutputPort())
    mapBookshelf1RHS.ScalarVisibilityOff()
    bookshelf1RHSActor = vtkActor()
    bookshelf1RHSActor.SetMapper(mapBookshelf1RHS)
    bookshelf1RHSActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf2Top = vtkStructuredGridGeometryFilter()
    bookshelf2Top.SetInputData(reader.GetStructuredGridOutput())
    bookshelf2Top.SetExtent(13, 13, 15, 19, 0, 11)
    mapBookshelf2Top = vtkPolyDataMapper()
    mapBookshelf2Top.SetInputConnection(bookshelf2Top.GetOutputPort())
    mapBookshelf2Top.ScalarVisibilityOff()
    bookshelf2TopActor = vtkActor()
    bookshelf2TopActor.SetMapper(mapBookshelf2Top)
    bookshelf2TopActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf2Bottom = vtkStructuredGridGeometryFilter()
    bookshelf2Bottom.SetInputData(reader.GetStructuredGridOutput())
    bookshelf2Bottom.SetExtent(20, 20, 15, 19, 0, 11)
    mapBookshelf2Bottom = vtkPolyDataMapper()
    mapBookshelf2Bottom.SetInputConnection(bookshelf2Bottom.GetOutputPort())
    mapBookshelf2Bottom.ScalarVisibilityOff()
    bookshelf2BottomActor = vtkActor()
    bookshelf2BottomActor.SetMapper(mapBookshelf2Bottom)
    bookshelf2BottomActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf2Front = vtkStructuredGridGeometryFilter()
    bookshelf2Front.SetInputData(reader.GetStructuredGridOutput())
    bookshelf2Front.SetExtent(13, 20, 15, 15, 0, 11)
    mapBookshelf2Front = vtkPolyDataMapper()
    mapBookshelf2Front.SetInputConnection(bookshelf2Front.GetOutputPort())
    mapBookshelf2Front.ScalarVisibilityOff()
    bookshelf2FrontActor = vtkActor()
    bookshelf2FrontActor.SetMapper(mapBookshelf2Front)
    bookshelf2FrontActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf2Back = vtkStructuredGridGeometryFilter()
    bookshelf2Back.SetInputData(reader.GetStructuredGridOutput())
    bookshelf2Back.SetExtent(13, 20, 19, 19, 0, 11)
    mapBookshelf2Back = vtkPolyDataMapper()
    mapBookshelf2Back.SetInputConnection(bookshelf2Back.GetOutputPort())
    mapBookshelf2Back.ScalarVisibilityOff()
    bookshelf2BackActor = vtkActor()
    bookshelf2BackActor.SetMapper(mapBookshelf2Back)
    bookshelf2BackActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf2LHS = vtkStructuredGridGeometryFilter()
    bookshelf2LHS.SetInputData(reader.GetStructuredGridOutput())
    bookshelf2LHS.SetExtent(13, 20, 15, 19, 0, 0)
    mapBookshelf2LHS = vtkPolyDataMapper()
    mapBookshelf2LHS.SetInputConnection(bookshelf2LHS.GetOutputPort())
    mapBookshelf2LHS.ScalarVisibilityOff()
    bookshelf2LHSActor = vtkActor()
    bookshelf2LHSActor.SetMapper(mapBookshelf2LHS)
    bookshelf2LHSActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf2RHS = vtkStructuredGridGeometryFilter()
    bookshelf2RHS.SetInputData(reader.GetStructuredGridOutput())
    bookshelf2RHS.SetExtent(13, 20, 15, 19, 11, 11)
    mapBookshelf2RHS = vtkPolyDataMapper()
    mapBookshelf2RHS.SetInputConnection(bookshelf2RHS.GetOutputPort())
    mapBookshelf2RHS.ScalarVisibilityOff()
    bookshelf2RHSActor = vtkActor()
    bookshelf2RHSActor.SetMapper(mapBookshelf2RHS)
    bookshelf2RHSActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    window = vtkStructuredGridGeometryFilter()
    window.SetInputData(reader.GetStructuredGridOutput())
    window.SetExtent(20, 20, 6, 13, 10, 13)
    mapWindow = vtkPolyDataMapper()
    mapWindow.SetInputConnection(window.GetOutputPort())
    mapWindow.ScalarVisibilityOff()
    windowActor = vtkActor()
    windowActor.SetMapper(mapWindow)
    windowActor.GetProperty().SetColor(colors.GetColor3d('WindowColor'))

    outlet = vtkStructuredGridGeometryFilter()
    outlet.SetInputData(reader.GetStructuredGridOutput())
    outlet.SetExtent(0, 0, 9, 10, 14, 16)
    mapOutlet = vtkPolyDataMapper()
    mapOutlet.SetInputConnection(outlet.GetOutputPort())
    mapOutlet.ScalarVisibilityOff()
    outletActor = vtkActor()
    outletActor.SetMapper(mapOutlet)
    outletActor.GetProperty().SetColor(colors.GetColor3d('lamp_black'))

    inlet = vtkStructuredGridGeometryFilter()
    inlet.SetInputData(reader.GetStructuredGridOutput())
    inlet.SetExtent(0, 0, 9, 10, 0, 6)
    mapInlet = vtkPolyDataMapper()
    mapInlet.SetInputConnection(inlet.GetOutputPort())
    mapInlet.ScalarVisibilityOff()
    inletActor = vtkActor()
    inletActor.SetMapper(mapInlet)
    inletActor.GetProperty().SetColor(colors.GetColor3d('lamp_black'))

    outline = vtkStructuredGridOutlineFilter()
    outline.SetInputData(reader.GetStructuredGridOutput())
    mapOutline = vtkPolyDataMapper()
    mapOutline.SetInputConnection(outline.GetOutputPort())
    outlineActor = vtkActor()
    outlineActor.SetMapper(mapOutline)
    outlineActor.GetProperty().SetColor(colors.GetColor3d('Black'))

    # Create the source for the streamtubes.
    seeds = vtkPointSource()
    seeds.SetRadius(0.075)
    seeds.SetCenter(seedCenters[center])
    seeds.SetNumberOfPoints(25)
    streamers = vtkStreamTracer()
    streamers.SetInputConnection(reader.GetOutputPort())
    streamers.SetSourceConnection(seeds.GetOutputPort())
    streamers.SetMaximumPropagation(500)
    streamers.SetMinimumIntegrationStep(0.1)
    streamers.SetMaximumIntegrationStep(1.0)
--
    mapStreamers = vtkPolyDataMapper()
    mapStreamers.SetInputConnection(streamers.GetOutputPort())
    mapStreamers.SetScalarRange(reader.GetOutput().GetPointData().GetScalars().GetRange())
    streamersActor = vtkActor()
    streamersActor.SetMapper(mapStreamers)

    # Create the rendering window, renderer, and interactive renderer.
    ren = vtkRenderer()
    renWin = vtkRenderWindow()
    renWin.AddRenderer(ren)
    renWin.SetWindowName('Office')

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(renWin)

    # Add the remaining actors to the renderer, set the background and size.
    ren.AddActor(table1Actor)
    ren.AddActor(table2Actor)
--
    aCamera = vtkCamera()
    aCamera.SetClippingRange(0.726079, 36.3039)
    aCamera.SetFocalPoint(2.43584, 2.15046, 1.11104)
    aCamera.SetPosition(-4.76183, -10.4426, 3.17203)
    aCamera.ComputeViewPlaneNormal()
    aCamera.SetViewUp(0.0511273, 0.132773, 0.989827)
--
    description = 'Demonstrate the use of vtkPointSource to generate streamlines.'
    epilogue = '''
    center: An optional parameter choosing the center for the seeds.
        0 - Corresponds to Fig 9-47(a) in the VTK textbook.
        1 - A slight shift to the left.
        2 - A slight shift to the upper left (from the original code).
--
    parser.add_argument('fileName', help='office.binary.vtk')
    parser.add_argument('center', default=3, type=int, nargs='?', help='seed center.')
    args = parser.parse_args()
    return args.fileName, args.center


--
    colors = vtkNamedColors()
    # Set the furniture colors, matching those in the VTKTextBook.
    tableTopColor = [0.59, 0.427, 0.392]
    filingCabinetColor = [0.8, 0.8, 0.6]
    bookShelfColor = [0.8, 0.8, 0.6]
    windowColor = [0.3, 0.3, 0.5]
--
    reader = vtkDataSetReader()
    reader.SetFileName(fileName)
    reader.Update()

    # Now we will generate a single streamline in the data. We select the
    # integration order to use (RungeKutta order 4) and associate it with
--
    integ = vtkRungeKutta4()

    streamer = vtkStreamTracer()
    streamer.SetInputConnection(reader.GetOutputPort())
    streamer.SetStartPosition(0.1, 2.1, 0.5)
    streamer.SetMaximumPropagation(500)
    streamer.SetInitialIntegrationStep(0.05)
    streamer.SetIntegrationDirectionToBoth()
--
    streamTube = vtkTubeFilter()
    streamTube.SetInputConnection(streamer.GetOutputPort())
    streamTube.SetInputArrayToProcess(1, 0, 0, vtkDataObject.FIELD_ASSOCIATION_POINTS, 'vectors')
    streamTube.SetRadius(0.02)
    streamTube.SetNumberOfSides(12)
    streamTube.SetVaryRadiusToVaryRadiusByVector()
--
    mapStreamTube = vtkPolyDataMapper()
    mapStreamTube.SetInputConnection(streamTube.GetOutputPort())
    mapStreamTube.SetScalarRange(reader.GetOutput().GetPointData().GetScalars().GetRange())

    streamTubeActor = vtkActor()
    streamTubeActor.SetMapper(mapStreamTube)
    streamTubeActor.GetProperty().BackfaceCullingOn()

    # Create the scene.
    # We generate a whole bunch of planes which correspond to
--
    table1 = vtkStructuredGridGeometryFilter()
    table1.SetInputData(reader.GetStructuredGridOutput())
    table1.SetExtent(11, 15, 7, 9, 8, 8)
    mapTable1 = vtkPolyDataMapper()
    mapTable1.SetInputConnection(table1.GetOutputPort())
    mapTable1.ScalarVisibilityOff()
    table1Actor = vtkActor()
    table1Actor.SetMapper(mapTable1)
    table1Actor.GetProperty().SetColor(colors.GetColor3d('TableTop'))

    table2 = vtkStructuredGridGeometryFilter()
    table2.SetInputData(reader.GetStructuredGridOutput())
    table2.SetExtent(11, 15, 10, 12, 8, 8)
    mapTable2 = vtkPolyDataMapper()
    mapTable2.SetInputConnection(table2.GetOutputPort())
    mapTable2.ScalarVisibilityOff()
    table2Actor = vtkActor()
    table2Actor.SetMapper(mapTable2)
    table2Actor.GetProperty().SetColor(colors.GetColor3d('TableTop'))

    FilingCabinet1 = vtkStructuredGridGeometryFilter()
    FilingCabinet1.SetInputData(reader.GetStructuredGridOutput())
    FilingCabinet1.SetExtent(15, 15, 7, 9, 0, 8)
    mapFilingCabinet1 = vtkPolyDataMapper()
    mapFilingCabinet1.SetInputConnection(FilingCabinet1.GetOutputPort())
    mapFilingCabinet1.ScalarVisibilityOff()
    FilingCabinet1Actor = vtkActor()
    FilingCabinet1Actor.SetMapper(mapFilingCabinet1)
    FilingCabinet1Actor.GetProperty().SetColor(colors.GetColor3d('FilingCabinet'))

    FilingCabinet2 = vtkStructuredGridGeometryFilter()
    FilingCabinet2.SetInputData(reader.GetStructuredGridOutput())
    FilingCabinet2.SetExtent(15, 15, 10, 12, 0, 8)
    mapFilingCabinet2 = vtkPolyDataMapper()
    mapFilingCabinet2.SetInputConnection(FilingCabinet2.GetOutputPort())
    mapFilingCabinet2.ScalarVisibilityOff()
    FilingCabinet2Actor = vtkActor()
    FilingCabinet2Actor.SetMapper(mapFilingCabinet2)
    FilingCabinet2Actor.GetProperty().SetColor(colors.GetColor3d('FilingCabinet'))

    bookshelf1Top = vtkStructuredGridGeometryFilter()
    bookshelf1Top.SetInputData(reader.GetStructuredGridOutput())
    bookshelf1Top.SetExtent(13, 13, 0, 4, 0, 11)
    mapBookshelf1Top = vtkPolyDataMapper()
    mapBookshelf1Top.SetInputConnection(bookshelf1Top.GetOutputPort())
    mapBookshelf1Top.ScalarVisibilityOff()
    bookshelf1TopActor = vtkActor()
    bookshelf1TopActor.SetMapper(mapBookshelf1Top)
    bookshelf1TopActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf1Bottom = vtkStructuredGridGeometryFilter()
    bookshelf1Bottom.SetInputData(reader.GetStructuredGridOutput())
    bookshelf1Bottom.SetExtent(20, 20, 0, 4, 0, 11)
    mapBookshelf1Bottom = vtkPolyDataMapper()
    mapBookshelf1Bottom.SetInputConnection(bookshelf1Bottom.GetOutputPort())
    mapBookshelf1Bottom.ScalarVisibilityOff()
    bookshelf1BottomActor = vtkActor()
    bookshelf1BottomActor.SetMapper(mapBookshelf1Bottom)
    bookshelf1BottomActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf1Front = vtkStructuredGridGeometryFilter()
    bookshelf1Front.SetInputData(reader.GetStructuredGridOutput())
    bookshelf1Front.SetExtent(13, 20, 0, 0, 0, 11)
    mapBookshelf1Front = vtkPolyDataMapper()
    mapBookshelf1Front.SetInputConnection(bookshelf1Front.GetOutputPort())
    mapBookshelf1Front.ScalarVisibilityOff()
    bookshelf1FrontActor = vtkActor()
    bookshelf1FrontActor.SetMapper(mapBookshelf1Front)
    bookshelf1FrontActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf1Back = vtkStructuredGridGeometryFilter()
    bookshelf1Back.SetInputData(reader.GetStructuredGridOutput())
    bookshelf1Back.SetExtent(13, 20, 4, 4, 0, 11)
    mapBookshelf1Back = vtkPolyDataMapper()
    mapBookshelf1Back.SetInputConnection(bookshelf1Back.GetOutputPort())
    mapBookshelf1Back.ScalarVisibilityOff()
    bookshelf1BackActor = vtkActor()
    bookshelf1BackActor.SetMapper(mapBookshelf1Back)
    bookshelf1BackActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf1LHS = vtkStructuredGridGeometryFilter()
    bookshelf1LHS.SetInputData(reader.GetStructuredGridOutput())
    bookshelf1LHS.SetExtent(13, 20, 0, 4, 0, 0)
    mapBookshelf1LHS = vtkPolyDataMapper()
    mapBookshelf1LHS.SetInputConnection(bookshelf1LHS.GetOutputPort())
    mapBookshelf1LHS.ScalarVisibilityOff()
    bookshelf1LHSActor = vtkActor()
    bookshelf1LHSActor.SetMapper(mapBookshelf1LHS)
    bookshelf1LHSActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf1RHS = vtkStructuredGridGeometryFilter()
    bookshelf1RHS.SetInputData(reader.GetStructuredGridOutput())
    bookshelf1RHS.SetExtent(13, 20, 0, 4, 11, 11)
    mapBookshelf1RHS = vtkPolyDataMapper()
    mapBookshelf1RHS.SetInputConnection(bookshelf1RHS.GetOutputPort())
    mapBookshelf1RHS.ScalarVisibilityOff()
    bookshelf1RHSActor = vtkActor()
    bookshelf1RHSActor.SetMapper(mapBookshelf1RHS)
    bookshelf1RHSActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf2Top = vtkStructuredGridGeometryFilter()
    bookshelf2Top.SetInputData(reader.GetStructuredGridOutput())
    bookshelf2Top.SetExtent(13, 13, 15, 19, 0, 11)
    mapBookshelf2Top = vtkPolyDataMapper()
    mapBookshelf2Top.SetInputConnection(bookshelf2Top.GetOutputPort())
    mapBookshelf2Top.ScalarVisibilityOff()
    bookshelf2TopActor = vtkActor()
    bookshelf2TopActor.SetMapper(mapBookshelf2Top)
    bookshelf2TopActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf2Bottom = vtkStructuredGridGeometryFilter()
    bookshelf2Bottom.SetInputData(reader.GetStructuredGridOutput())
    bookshelf2Bottom.SetExtent(20, 20, 15, 19, 0, 11)
    mapBookshelf2Bottom = vtkPolyDataMapper()
    mapBookshelf2Bottom.SetInputConnection(bookshelf2Bottom.GetOutputPort())
    mapBookshelf2Bottom.ScalarVisibilityOff()
    bookshelf2BottomActor = vtkActor()
    bookshelf2BottomActor.SetMapper(mapBookshelf2Bottom)
    bookshelf2BottomActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf2Front = vtkStructuredGridGeometryFilter()
    bookshelf2Front.SetInputData(reader.GetStructuredGridOutput())
    bookshelf2Front.SetExtent(13, 20, 15, 15, 0, 11)
    mapBookshelf2Front = vtkPolyDataMapper()
    mapBookshelf2Front.SetInputConnection(bookshelf2Front.GetOutputPort())
    mapBookshelf2Front.ScalarVisibilityOff()
    bookshelf2FrontActor = vtkActor()
    bookshelf2FrontActor.SetMapper(mapBookshelf2Front)
    bookshelf2FrontActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf2Back = vtkStructuredGridGeometryFilter()
    bookshelf2Back.SetInputData(reader.GetStructuredGridOutput())
    bookshelf2Back.SetExtent(13, 20, 19, 19, 0, 11)
    mapBookshelf2Back = vtkPolyDataMapper()
    mapBookshelf2Back.SetInputConnection(bookshelf2Back.GetOutputPort())
    mapBookshelf2Back.ScalarVisibilityOff()
    bookshelf2BackActor = vtkActor()
    bookshelf2BackActor.SetMapper(mapBookshelf2Back)
    bookshelf2BackActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf2LHS = vtkStructuredGridGeometryFilter()
    bookshelf2LHS.SetInputData(reader.GetStructuredGridOutput())
    bookshelf2LHS.SetExtent(13, 20, 15, 19, 0, 0)
    mapBookshelf2LHS = vtkPolyDataMapper()
    mapBookshelf2LHS.SetInputConnection(bookshelf2LHS.GetOutputPort())
    mapBookshelf2LHS.ScalarVisibilityOff()
    bookshelf2LHSActor = vtkActor()
    bookshelf2LHSActor.SetMapper(mapBookshelf2LHS)
    bookshelf2LHSActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    bookshelf2RHS = vtkStructuredGridGeometryFilter()
    bookshelf2RHS.SetInputData(reader.GetStructuredGridOutput())
    bookshelf2RHS.SetExtent(13, 20, 15, 19, 11, 11)
    mapBookshelf2RHS = vtkPolyDataMapper()
    mapBookshelf2RHS.SetInputConnection(bookshelf2RHS.GetOutputPort())
    mapBookshelf2RHS.ScalarVisibilityOff()
    bookshelf2RHSActor = vtkActor()
    bookshelf2RHSActor.SetMapper(mapBookshelf2RHS)
    bookshelf2RHSActor.GetProperty().SetColor(colors.GetColor3d('BookShelf'))

    window = vtkStructuredGridGeometryFilter()
    window.SetInputData(reader.GetStructuredGridOutput())
    window.SetExtent(20, 20, 6, 13, 10, 13)
    mapWindow = vtkPolyDataMapper()
    mapWindow.SetInputConnection(window.GetOutputPort())
    mapWindow.ScalarVisibilityOff()
    windowActor = vtkActor()
    windowActor.SetMapper(mapWindow)
    windowActor.GetProperty().SetColor(colors.GetColor3d('WindowColor'))

    outlet = vtkStructuredGridGeometryFilter()
    outlet.SetInputData(reader.GetStructuredGridOutput())
    outlet.SetExtent(0, 0, 9, 10, 14, 16)
    mapOutlet = vtkPolyDataMapper()
    mapOutlet.SetInputConnection(outlet.GetOutputPort())
    mapOutlet.ScalarVisibilityOff()
    outletActor = vtkActor()
    outletActor.SetMapper(mapOutlet)
    outletActor.GetProperty().SetColor(colors.GetColor3d('lamp_black'))

    inlet = vtkStructuredGridGeometryFilter()
    inlet.SetInputData(reader.GetStructuredGridOutput())
    inlet.SetExtent(0, 0, 9, 10, 0, 6)
    mapInlet = vtkPolyDataMapper()
    mapInlet.SetInputConnection(inlet.GetOutputPort())
    mapInlet.ScalarVisibilityOff()
    inletActor = vtkActor()
    inletActor.SetMapper(mapInlet)
    inletActor.GetProperty().SetColor(colors.GetColor3d('lamp_black'))

    outline = vtkStructuredGridOutlineFilter()
    outline.SetInputData(reader.GetStructuredGridOutput())
    mapOutline = vtkPolyDataMapper()
    mapOutline.SetInputConnection(outline.GetOutputPort())
    outlineActor = vtkActor()
    outlineActor.SetMapper(mapOutline)
    outlineActor.GetProperty().SetColor(colors.GetColor3d('Black'))

    # Create the rendering window, renderer, and interactive renderer.
    ren = vtkRenderer()
    renWin = vtkRenderWindow()
    renWin.AddRenderer(ren)
    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(renWin)

    # Add the remaining actors to the renderer, set the background and size.
    ren.AddActor(table1Actor)
    ren.AddActor(table2Actor)
--
    aCamera = vtkCamera()
    aCamera.SetClippingRange(0.726079, 36.3039)
    aCamera.SetFocalPoint(2.43584, 2.15046, 1.11104)
    aCamera.SetPosition(-4.76183, -10.4426, 3.17203)
    aCamera.ComputeViewPlaneNormal()
    aCamera.SetViewUp(0.0511273, 0.132773, 0.989827)
--
    parser.add_argument('fileName', help='office.binary.vtk')
    args = parser.parse_args()
    return args.fileName


if __name__ == '__main__':
--
    colors = vtkNamedColors()

    # Set the colors.
    colors.SetColor('PlateColor', [255, 160, 140, 255])
    colors.SetColor('BkgColor', [65, 99, 149, 255])

--
    plate = vtkPolyDataReader()
    plate.SetFileName(file_name)
    plate.Update()
    bounds = [0] * 6
    plate.GetOutput().GetBounds(bounds)
    plate.SetVectorsName('mode2')
--
    normals = vtkPolyDataNormals()
    normals.SetInputConnection(plate.GetOutputPort())
    warp = vtkWarpVector()
    warp.SetInputConnection(normals.GetOutputPort())
    warp.SetScaleFactor(0.5)
    color = vtkVectorDot()
    color.SetInputConnection(warp.GetOutputPort())
    plateMapper = vtkDataSetMapper()
    plateMapper.SetInputConnection(warp.GetOutputPort())
    plateActor = vtkActor()
    plateActor.SetMapper(plateMapper)
    plateActor.GetProperty().SetColor(
        colors.GetColor3d('PlateColor'))
    plateActor.RotateX(-90)

--
    outline = vtkOutlineFilter()
    outline.SetInputConnection(plate.GetOutputPort())
    spikeMapper = vtkPolyDataMapper()
    spikeMapper.SetInputConnection(outline.GetOutputPort())
    outlineActor = vtkActor()
    outlineActor.SetMapper(spikeMapper)
    outlineActor.RotateX(-90)
    outlineActor.GetProperty().SetColor(colors.GetColor3d('White'))

    # Create the RenderWindow, Renderer and both Actors
--
    ren = vtkRenderer()
    renWin = vtkRenderWindow()
    renWin.AddRenderer(ren)

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(renWin)

    # Add the actors to the renderer, set the background and size
    #
    ren.AddActor(plateActor)
--
    parser.add_argument('filename', help='plate.vtk')
    args = parser.parse_args()
    return args.filename


if __name__ == '__main__':
--
    colors = vtkNamedColors()

    fran = vtkPolyDataReader()
    fran.SetFileName(fileName)

    normals = vtkPolyDataNormals()
    normals.SetInputConnection(fran.GetOutputPort())
    normals.FlipNormalsOn()

    franMapper = vtkPolyDataMapper()
    franMapper.SetInputConnection(normals.GetOutputPort())

    franActor = vtkActor()
    franActor.SetMapper(franMapper)
    franActor.GetProperty().SetColor(colors.GetColor3d('Flesh'))

    # We subsample the dataset because we want to glyph just a subset of
    # the points. Otherwise the display is cluttered and cannot be easily
--
    ptMask = vtkMaskPoints()
    ptMask.SetInputConnection(normals.GetOutputPort())
    ptMask.SetOnRatio(10)
    ptMask.RandomModeOn()

    # In this case we are using a cone as a glyph. We transform the cone so
--
    cone = vtkConeSource()
    cone.SetResolution(6)

    transform = vtkTransform()
    transform.Translate(0.5, 0.0, 0.0)

    transformF = vtkTransformPolyDataFilter()
    transformF.SetInputConnection(cone.GetOutputPort())
    transformF.SetTransform(transform)

    # vtkGlyph3D takes two inputs: the input point set (SetInputConnection)
    # which can be any vtkDataSet and the glyph (SetSourceConnection) which
--
    glyph = vtkGlyph3D()
    glyph.SetInputConnection(ptMask.GetOutputPort())
    glyph.SetSourceConnection(transformF.GetOutputPort())
    glyph.SetVectorModeToUseNormal()
    glyph.SetScaleModeToScaleByVector()
    glyph.SetScaleFactor(0.004)
--
    spikeMapper = vtkPolyDataMapper()
    spikeMapper.SetInputConnection(glyph.GetOutputPort())

    spikeActor = vtkActor()
    spikeActor.SetMapper(spikeMapper)
    spikeActor.GetProperty().SetColor(colors.GetColor3d('Emerald_Green'))

    # Create the RenderWindow, Renderer and Interactor.
    #
    ren1 = vtkRenderer()
    renWin = vtkRenderWindow()
    renWin.AddRenderer(ren1)

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(renWin)

    # Add the actors to the renderer, set the background and size.
    #
    ren1.AddActor(franActor)
--
    parser.add_argument('filename', help='fran_cut.vtk')
    args = parser.parse_args()
    return args.filename


if __name__ == '__main__':
--
    colors = vtkNamedColors()

    fileName = get_program_parameters()

    # Create the RenderWindow, Renderer and Interactor.
    #
    ren1 = vtkRenderer()
    renWin = vtkRenderWindow()
    renWin.AddRenderer(ren1)

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(renWin)

    # Read cyberware file.
    #
    cyber = vtkPolyDataReader()
    cyber.SetFileName(fileName)

    normals = vtkPolyDataNormals()
    normals.SetInputConnection(cyber.GetOutputPort())

    mask = vtkMaskPoints()
    mask.SetInputConnection(normals.GetOutputPort())
    mask.SetOnRatio(8)
    # mask.RandomModeOn()

    splatter = vtkGaussianSplatter()
    splatter.SetInputConnection(mask.GetOutputPort())
    splatter.SetSampleDimensions(100, 100, 100)
    splatter.SetEccentricity(2.5)
    splatter.NormalWarpingOn()
    splatter.SetScaleFactor(1.0)
--
    contour = vtkContourFilter()
    contour.SetInputConnection(splatter.GetOutputPort())
    contour.SetValue(0, 0.25)

    splatMapper = vtkPolyDataMapper()
    splatMapper.SetInputConnection(contour.GetOutputPort())
    splatMapper.ScalarVisibilityOff()

    splatActor = vtkActor()
    splatActor.SetMapper(splatMapper)
    splatActor.GetProperty().SetColor(colors.GetColor3d('Flesh'))

    cyberMapper = vtkPolyDataMapper()
    cyberMapper.SetInputConnection(cyber.GetOutputPort())
    cyberMapper.ScalarVisibilityOff()

    cyberActor = vtkActor()
    cyberActor.SetMapper(cyberMapper)
    cyberActor.GetProperty().SetRepresentationToWireframe()
    cyberActor.GetProperty().SetColor(colors.GetColor3d('Turquoise'))

    # Add the actors to the renderer, set the background and size.
--
    camera = vtkCamera()
    camera.SetClippingRange(0.0332682, 1.66341)
    camera.SetFocalPoint(0.0511519, -0.127555, -0.0554379)
    camera.SetPosition(0.516567, -0.124763, -0.349538)
    camera.SetViewAngle(18.1279)
    camera.SetViewUp(-0.013125, 0.99985, -0.0112779)
--
    parser.add_argument('filename', help='fran_cut.vtk')
    args = parser.parse_args()
    return args.filename


if __name__ == '__main__':
--
    colors = vtkNamedColors()

    fileNames, useRibbons = get_program_parameters()
    useTubes = not useRibbons

    # Set up the stocks
--
    topRenderer = vtkRenderer()
    bottomRenderer = vtkRenderer()
    renderers.append(topRenderer)
    renderers.append(bottomRenderer)

    zPosition = 0.0
    for fn in fileNames:
--
    renderWindow = vtkRenderWindow()
    renderWindow.AddRenderer(renderers[0])
    renderWindow.AddRenderer(renderers[1])

    renderWindowInteractor = vtkRenderWindowInteractor()
    renderWindowInteractor.SetRenderWindow(renderWindow)

    renderers[0].SetViewport(0.0, 0.4, 1.0, 1.0)
    renderers[1].SetViewport(0.0, 0.0, 1.0, 0.4)

--
                        help='List of one or more filenames corresponding to stocks. e.g. GE.vtk GM.vtk IBM.vtk DEC.vtk')
    parser.add_argument('-r', dest='useRibbons', action='store_true', help='Use ribbons instead of tubes.')

    args = parser.parse_args()
    return args.filenames, args.useRibbons

--
    PolyDataRead = vtkPolyDataReader()
    PolyDataRead.SetFileName(filename)
    PolyDataRead.Update()

    # Create the labels.
    TextSrc = vtkVectorText()
    TextSrc.SetText(name)

    numberOfPoints = PolyDataRead.GetOutput().GetNumberOfPoints()

    nameIndex = int((numberOfPoints - 1) * 0.8)
--
    TubeFilter = vtkTubeFilter()
    TubeFilter.SetInputConnection(PolyDataRead.GetOutputPort())
    TubeFilter.SetNumberOfSides(8)
    TubeFilter.SetRadius(0.5)
    TubeFilter.SetRadiusFactor(10000)

    RibbonFilter = vtkRibbonFilter()
    RibbonFilter.SetInputConnection(PolyDataRead.GetOutputPort())
    RibbonFilter.VaryWidthOn()
    RibbonFilter.SetWidthFactor(5)
    RibbonFilter.SetDefaultNormal(0, 1, 0)
    RibbonFilter.UseDefaultNormalOn()
--
    Extrude = vtkLinearExtrusionFilter()
    Extrude.SetInputConnection(RibbonFilter.GetOutputPort())
    Extrude.SetVector(0, 1, 0)
    Extrude.SetExtrusionType(1)
    Extrude.SetScaleFactor(0.7)

    Transform = vtkTransform()
    Transform.Translate(0, 0, zPosition)
    Transform.Scale(0.15, 1, 1)

    TransformFilter = vtkTransformPolyDataFilter()
    TransformFilter.SetInputConnection(Extrude.GetOutputPort())
    TransformFilter.SetTransform(Transform)

    # Select tubes or ribbons
    if useTubes:
--
        LabelMapper = vtkPolyDataMapper()
        LabelMapper.SetInputConnection(TextSrc.GetOutputPort())

        LabelActor = vtkFollower()
        LabelActor.SetMapper(LabelMapper)
        LabelActor.SetPosition(x, y, z)
        LabelActor.SetScale(2, 2, 2)
        LabelActor.SetOrigin(TextSrc.GetOutput().GetCenter())

--
        StockMapper = vtkPolyDataMapper()
        StockMapper.SetInputConnection(TransformFilter.GetOutputPort())
        StockMapper.SetScalarRange(0, 8000)
        StockActor = vtkActor()
        StockActor.SetMapper(StockMapper)

        renderers[r].AddActor(StockActor)
        renderers[r].AddActor(LabelActor)
        LabelActor.SetCamera(renderers[r].GetActiveCamera())
--
    colors = vtkNamedColors()

    # Create the RenderWindow, Renderer and interactive renderer.
    #
    ren = vtkRenderer()
    renWin = vtkRenderWindow()
    renWin.AddRenderer(ren)
    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(renWin)

    # Generate the tensors.
    ptLoad = vtkPointLoad()
    ptLoad.SetLoadValue(100.0)
    ptLoad.SetSampleDimensions(6, 6, 6)
    ptLoad.ComputeEffectiveStressOn()
    ptLoad.SetModelBounds(-10, 10, -10, 10, -10, 10)

--
    plane = vtkImageDataGeometryFilter()
    plane.SetInputConnection(ptLoad.GetOutputPort())
    plane.SetExtent(2, 2, 0, 99, 0, 99)

    # Generate the tensor axes.
    axes = vtkAxes()
    axes.SetScaleFactor(0.5)

    tubeAxes = vtkTubeFilter()
    tubeAxes.SetInputConnection(axes.GetOutputPort())
    tubeAxes.SetRadius(0.1)
    tubeAxes.SetNumberOfSides(6)

    tensorAxes = vtkTensorGlyph()
    tensorAxes.SetInputConnection(ptLoad.GetOutputPort())
    tensorAxes.SetSourceConnection(axes.GetOutputPort())
    tensorAxes.SetScaleFactor(10)
    tensorAxes.ClampScalingOn()

--
    lut = vtkLookupTable()
    MakeLogLUT(lut)
    # lut.SetHueRange(.6667, 0.0)
    tensorAxesMapper = vtkPolyDataMapper()
    tensorAxesMapper.SetInputConnection(tensorAxes.GetOutputPort())
    tensorAxesMapper.SetLookupTable(lut)
    plane.Update()  # force update for scalar range
    # This is deprecated from vtk 8.1 onwards.
    # tensorAxesMapper.ImmediateModeRenderingOn()
--
    tensorActor = vtkActor()
    tensorActor.SetMapper(tensorAxesMapper)

    # Create an outline around the data.
    #
    outline = vtkOutlineFilter()
    outline.SetInputConnection(ptLoad.GetOutputPort())

    outlineMapper = vtkPolyDataMapper()
    outlineMapper.SetInputConnection(outline.GetOutputPort())

    outlineActor = vtkActor()
    outlineActor.SetMapper(outlineMapper)
    outlineActor.GetProperty().SetColor(colors.GetColor3d('Black'))

    #
    # Create a cone whose apex indicates the application of load.
--
    coneSrc = vtkConeSource()
    coneSrc.SetRadius(.5)
    coneSrc.SetHeight(2)
    coneMap = vtkPolyDataMapper()
    coneMap.SetInputConnection(coneSrc.GetOutputPort())
    coneActor = vtkActor()
    coneActor.SetMapper(coneMap)
    coneActor.SetPosition(0, 0, 11)
    coneActor.RotateY(90)
    coneActor.GetProperty().SetColor(colors.GetColor3d('BurlyWood'))

    camera = vtkCamera()
    camera.SetFocalPoint(0.113766, -1.13665, -1.01919)
    camera.SetPosition(-29.4886, -63.1488, 26.5807)
    camera.SetViewAngle(24.4617)
    camera.SetViewUp(0.17138, 0.331163, 0.927879)
    camera.SetClippingRange(1, 100)
--
    colors = vtkNamedColors()

    # Set the background color.
    colors.SetColor('BkgColor', [65, 99, 149, 255])

    # Read a vtk file
--
    pl3d = vtkMultiBlockPLOT3DReader()
    pl3d.SetXYZFileName(fileName1)
    pl3d.SetQFileName(fileName2)
    pl3d.SetScalarFunctionNumber(100)  # Density
    pl3d.SetVectorFunctionNumber(202)  # Momentum
    pl3d.Update()
--
    plane = vtkStructuredGridGeometryFilter()
    plane.SetInputData(pl3dOutput)
    plane.SetExtent(10, 10, 1, extent[3], 1, extent[5])

    plane2 = vtkStructuredGridGeometryFilter()
    plane2.SetInputData(pl3dOutput)
    plane2.SetExtent(30, 30, 1, extent[3], 1, extent[5])

    plane3 = vtkStructuredGridGeometryFilter()
    plane3.SetInputData(pl3dOutput)
    plane3.SetExtent(45, 45, 1, extent[3], 1, extent[5])

    # We use an append filter because that way we can do the warping, etc. just
    # using a single pipeline and actor.
--
    appendF = vtkAppendPolyData()
    appendF.AddInputConnection(plane.GetOutputPort())
    appendF.AddInputConnection(plane2.GetOutputPort())
    appendF.AddInputConnection(plane3.GetOutputPort())

    # Warp
    warp = vtkWarpVector()
    warp.SetInputConnection(appendF.GetOutputPort())
    warp.SetScaleFactor(0.005)
    warp.Update()

    normals = vtkPolyDataNormals()
    normals.SetInputData(warp.GetPolyDataOutput())
    normals.SetFeatureAngle(45)

    planeMapper = vtkPolyDataMapper()
    planeMapper.SetInputConnection(normals.GetOutputPort())
    planeMapper.SetScalarRange(scalarRange)

    planeActor = vtkActor()
    planeActor.SetMapper(planeMapper)

    # The outline provides context for the data and the planes.
    outline = vtkStructuredGridOutlineFilter()
    outline.SetInputData(pl3dOutput)

    outlineMapper = vtkPolyDataMapper()
    outlineMapper.SetInputConnection(outline.GetOutputPort())

    outlineActor = vtkActor()
    outlineActor.SetMapper(outlineMapper)
    outlineActor.GetProperty().SetColor(colors.GetColor3d('Black'))

    # Create the RenderWindow, Renderer and both Actors
    #
    ren = vtkRenderer()
    renWin = vtkRenderWindow()
    renWin.AddRenderer(ren)

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(renWin)

    # Add the actors to the renderer, set the background and size
    #
    ren.AddActor(planeActor)
--
    colors = vtkNamedColors()

    fileName1, fileName2, fileName3 = get_program_parameters()
    aRenderer = vtkRenderer()
    aRenderWindow = vtkRenderWindow()
    aRenderWindow.AddRenderer(aRenderer)
    anInteractor = vtkRenderWindowInteractor()
    anInteractor.SetRenderWindow(aRenderWindow)
    aRenderWindow.SetSize(300, 300)
    aRenderWindow.SetWindowName('BlobbyLogo')

    # Read the geometry file containing the letter v.
    letterV = vtkPolyDataReader()
    letterV.SetFileName(fileName1)

    # Read the geometry file containing the letter t.
    letterT = vtkPolyDataReader()
    letterT.SetFileName(fileName2)

    # Read the geometry file containing the letter k.
    letterK = vtkPolyDataReader()
    letterK.SetFileName(fileName3)

    # Create a transform and transform filter for each letter.
    VTransform = vtkTransform()
    VTransformFilter = vtkTransformPolyDataFilter()
    VTransformFilter.SetInputConnection(letterV.GetOutputPort())
    VTransformFilter.SetTransform(VTransform)

    TTransform = vtkTransform()
    TTransformFilter = vtkTransformPolyDataFilter()
    TTransformFilter.SetInputConnection(letterT.GetOutputPort())
    TTransformFilter.SetTransform(TTransform)

    KTransform = vtkTransform()
    KTransformFilter = vtkTransformPolyDataFilter()
    KTransformFilter.SetInputConnection(letterK.GetOutputPort())
    KTransformFilter.SetTransform(KTransform)

    # Now append them all.
    appendAll = vtkAppendPolyData()
    appendAll.AddInputConnection(VTransformFilter.GetOutputPort())
    appendAll.AddInputConnection(TTransformFilter.GetOutputPort())
    appendAll.AddInputConnection(KTransformFilter.GetOutputPort())

    # Create normals.
    logoNormals = vtkPolyDataNormals()
    logoNormals.SetInputConnection(appendAll.GetOutputPort())
    logoNormals.SetFeatureAngle(60)

    # Map to rendering primitives.
    logoMapper = vtkPolyDataMapper()
    logoMapper.SetInputConnection(logoNormals.GetOutputPort())

    # Now an actor.
    logo = vtkActor()
    logo.SetMapper(logoMapper)

    # Now create an implicit model of the same letter.
    blobbyLogoImp = vtkImplicitModeller()
    blobbyLogoImp.SetInputConnection(appendAll.GetOutputPort())
    blobbyLogoImp.SetMaximumDistance(.075)
    blobbyLogoImp.SetSampleDimensions(64, 64, 64)
    blobbyLogoImp.SetAdjustDistance(0.05)

--
    blobbyLogoIso = vtkContourFilter()
    blobbyLogoIso.SetInputConnection(blobbyLogoImp.GetOutputPort())
    blobbyLogoIso.SetValue(1, 1.5)

    # Map to rendering primitives.
    blobbyLogoMapper = vtkPolyDataMapper()
    blobbyLogoMapper.SetInputConnection(blobbyLogoIso.GetOutputPort())
    blobbyLogoMapper.ScalarVisibilityOff()

    tomato = vtkProperty()
    tomato.SetDiffuseColor(colors.GetColor3d('tomato'))
    tomato.SetSpecular(.3)
    tomato.SetSpecularPower(20)

    banana = vtkProperty()
    banana.SetDiffuseColor(colors.GetColor3d('banana'))
    banana.SetDiffuse(.7)
    banana.SetSpecular(.4)
    banana.SetSpecularPower(20)

--
    blobbyLogo = vtkActor()
    blobbyLogo.SetMapper(blobbyLogoMapper)
    blobbyLogo.SetProperty(banana)

    # Position the letters.

--
    parser.add_argument('filename1', help='v.vtk')
    parser.add_argument('filename2', help='t.vtk')
    parser.add_argument('filename3', help='k.vtk')
    args = parser.parse_args()
    return args.filename1, args.filename2, args.filename3


if __name__ == '__main__':
--
    colors = vtkNamedColors()

    thickness = list()
    displacement = list()
    for i in range(0, 10):
        thickness.append('thickness' + str(i))
--
    lut = vtkLookupTable()
    lut.SetHueRange(0.0, 0.66667)

    for i in range(0, 10):
        # Create the reader and warp the data vith vectors.
        reader.append(vtkDataSetReader())
--
    renWin = vtkRenderWindow()
    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(renWin)
    rendererSizeX = 750
    rendererSizeY = 400
    renWinScale = 0.5
    renWin.SetWindowName("Blow")
--
    parser.add_argument('filename', help='blow.vtk')
    parser.add_argument('-d', '--data_point', default=-1, type=int, nargs='?',
                        help='The frame to display (0...9).')
    args = parser.parse_args()
    return args.filename, args.data_point

--
    colors = vtkNamedColors()

    reader = vtkStructuredPointsReader()
    reader.SetFileName(fileName)

    hhog = vtkHedgeHog()
    hhog.SetInputConnection(reader.GetOutputPort())
    hhog.SetScaleFactor(0.3)

    lut = vtkLookupTable()
    # lut.SetHueRange(.667, 0.0)
    lut.Build()

    hhogMapper = vtkPolyDataMapper()
    hhogMapper.SetInputConnection(hhog.GetOutputPort())
    hhogMapper.SetScalarRange(50, 550)
    hhogMapper.SetLookupTable(lut)

    hhogActor = vtkActor()
    hhogActor.SetMapper(hhogMapper)

    outline = vtkOutlineFilter()
    outline.SetInputConnection(reader.GetOutputPort())

    outlineMapper = vtkPolyDataMapper()
    outlineMapper.SetInputConnection(outline.GetOutputPort())

    outlineActor = vtkActor()
    outlineActor.SetMapper(outlineMapper)
    outlineActor.GetProperty().SetColor(colors.GetColor3d('Black'))

    aRenderer = vtkRenderer()
    aRenderWindow = vtkRenderWindow()
    aRenderWindow.AddRenderer(aRenderer)
    anInteractor = vtkRenderWindowInteractor()
    anInteractor.SetRenderWindow(aRenderWindow)
    aRenderWindow.SetSize(640, 480)
    aRenderWindow.SetWindowName('ComplexV')

    aRenderer.AddActor(outlineActor)
--
    parser.add_argument('filename', help='carotid.vtk')
    args = parser.parse_args()
    return args.filename


if __name__ == '__main__':
--
    cc = vtkCurvatures()
    cc.SetInputData(source)
    needs_adjusting = ['Hills', 'ParametricTorus', 'Plane', 'RandomHills', 'Torus']
    if gaussian_curvature:
        cc.SetCurvatureTypeToGaussian()
        cc.Update()
--
    values = vtkVariantArray()
    for i in range(len(labels)):
        values.InsertNextValue(vtkVariant(labels[i]))
    for i in range(values.GetNumberOfTuples()):
        lut.SetAnnotation(i, values.GetValue(i).ToString())

--
    bcf = vtkBandedPolyDataContourFilter()
    bcf.SetInputData(cc.GetOutput())
    # Use either the minimum or maximum value for each band.
    for k in bands:
        bcf.SetValue(k, bands[k][2])
    # We will use an indexed lookup table.
--
    colors = vtkNamedColors()

    # Set the background color.
    colors.SetColor('BkgColor', [179, 204, 255, 255])
    colors.SetColor("ParaViewBkg", [82, 87, 110, 255])

    src_mapper = vtkPolyDataMapper()
    src_mapper.SetInputConnection(bcf.GetOutputPort())
    src_mapper.SetScalarRange(scalar_range_curvatures)
    src_mapper.SetLookupTable(lut)
    src_mapper.SetScalarModeToUseCellData()

    src_actor = vtkActor()
    src_actor.SetMapper(src_mapper)

    # Create contour edges
    edge_mapper = vtkPolyDataMapper()
    edge_mapper.SetInputData(bcf.GetContourEdgesOutput())
    edge_mapper.SetResolveCoincidentTopologyToPolygonOffset()

    edge_actor = vtkActor()
    edge_actor.SetMapper(edge_mapper)
    edge_actor.GetProperty().SetColor(colors.GetColor3d('Black'))

    glyph_mapper = vtkPolyDataMapper()
    glyph_mapper.SetInputConnection(glyph.GetOutputPort())
    glyph_mapper.SetScalarModeToUsePointFieldData()
    glyph_mapper.SetColorModeToMapScalars()
    glyph_mapper.ScalarVisibilityOn()
    glyph_mapper.SelectColorArray('Elevation')
--
    glyph_actor = vtkActor()
    glyph_actor.SetMapper(glyph_mapper)

    window_width = 800
    window_height = 800

--
    scalar_bar = vtkScalarBarActor()
    # This LUT puts the lowest value at the top of the scalar bar.
    # scalar_bar->SetLookupTable(lut);
    # Use this LUT if you want the highest value at the top.
    scalar_bar.SetLookupTable(lutr)
    scalar_bar.SetTitle(curvature.replace('_', '\n'))
--
    scalar_bar_elev = vtkScalarBarActor()
    # This LUT puts the lowest value at the top of the scalar bar.
    # scalar_bar_elev->SetLookupTable(lut);
    # Use this LUT if you want the highest value at the top.
    scalar_bar_elev.SetLookupTable(lut1)
    scalar_bar_elev.SetTitle('Elevation')
--
    ren = vtkRenderer()
    ren_win = vtkRenderWindow()
    iren = vtkRenderWindowInteractor()
    style = vtkInteractorStyleTrackballCamera()
    iren.SetInteractorStyle(style)

    ren_win.AddRenderer(ren)
    # Important: The interactor must be set prior to enabling the widget.
    iren.SetRenderWindow(ren_win)
--
        cam_orient_manipulator = vtkCameraOrientationWidget()
        cam_orient_manipulator = vtkCameraOrientationWidget()
        cam_orient_manipulator.SetParentRenderer(ren)
        # Enable the widget.
        cam_orient_manipulator.On()

    # add actors
--
    ver = vtkVersion()
    actual_version = (100 * ver.GetVTKMajorVersion() + ver.GetVTKMinorVersion()) \
                     * 100000000 + ver.GetVTKBuildVersion()
    if actual_version >= requested_version:
        return True
    else:
--
        cell_ids = vtkIdList()
        source.GetPointCells(pt_id, cell_ids)
        neighbour = set()
        for cell_idx in range(0, cell_ids.GetNumberOfIds()):
            cell_id = cell_ids.GetId(cell_idx)
            cell_point_ids = vtkIdList()
            source.GetCellPoints(cell_id, cell_point_ids)
            for cell_pt_idx in range(0, cell_point_ids.GetNumberOfIds()):
                neighbour.add(cell_point_ids.GetId(cell_pt_idx))
        return neighbour

--
    id_filter = vtkIdFilter()
    id_filter.SetInputData(source)
    id_filter.SetPointIds(True)
    id_filter.SetCellIds(False)
    id_filter.SetPointIdsArrayName(array_name)
    id_filter.SetCellIdsArrayName(array_name)
--
    edges = vtkFeatureEdges()
    edges.SetInputConnection(id_filter.GetOutputPort())
    edges.BoundaryEdgesOn()
    edges.ManifoldEdgesOff()
    edges.NonManifoldEdgesOff()
    edges.FeatureEdgesOff()
--
        curv = numpy_support.numpy_to_vtk(num_array=curvatures.ravel(),
                                          deep=True,
                                          array_type=VTK_DOUBLE)
        curv.SetName(curvature_name)
        source.GetPointData().RemoveArray(curvature_name)
        source.GetPointData().AddArray(curv)
--
    curv = numpy_support.numpy_to_vtk(num_array=curvatures.ravel(),
                                      deep=True,
                                      array_type=VTK_DOUBLE)
    curv.SetName(curvature_name)
    source.GetPointData().RemoveArray(curvature_name)
    source.GetPointData().AddArray(curv)
--
    elev_filter = vtkElevationFilter()
    elev_filter.SetInputData(src)
    elev_filter.SetLowPoint(0, bounds[2], 0)
    elev_filter.SetHighPoint(0, bounds[3], 0)
    elev_filter.SetScalarRange(bounds[2], bounds[3])
    elev_filter.Update()
--
    points = vtkPoints()
    for i in range(0, x_res):
        x = x_min + i * dx
        for j in range(0, y_res):
            y = y_min + j * dy
            points.InsertNextPoint(x, y, 0)
--
    plane = vtkPolyData()
    plane.SetPoints(points)

    # Triangulate the grid.
    delaunay = vtkDelaunay2D()
    delaunay.SetInputData(plane)
    delaunay.Update()

    polydata = delaunay.GetOutput()

    elevation = vtkDoubleArray()
    elevation.SetNumberOfTuples(points.GetNumberOfPoints())

    #  We define the parameters for the hills here.
    # [[0: x0, 1: y0, 2: x variance, 3: y variance, 4: amplitude]...]
    hd = [[-2.5, -2.5, 2.5, 6.5, 3.5], [2.5, 2.5, 2.5, 2.5, 2],
--
    textures = vtkFloatArray()
    textures.SetNumberOfComponents(2)
    textures.SetNumberOfTuples(2 * polydata.GetNumberOfPoints())
    textures.SetName("Textures")

    for i in range(0, x_res):
--
    normals = vtkPolyDataNormals()
    normals.SetInputData(polydata)
    normals.SetInputData(polydata)
    normals.SetFeatureAngle(30)
    normals.SplittingOff()

    tr1 = vtkTransform()
    tr1.RotateX(-90)

    tf1 = vtkTransformPolyDataFilter()
    tf1.SetInputConnection(normals.GetOutputPort())
    tf1.SetTransform(tr1)
    tf1.Update()

    return tf1.GetOutput()
--
    fn = vtkParametricRandomHills()
    fn.AllowRandomGenerationOn()
    fn.SetRandomSeed(1)
    fn.SetNumberOfHills(30)
    # Make the normals face out of the surface.
    # Not needed with VTK 8.0 or later.
    # if fn.GetClassName() == 'vtkParametricRandomHills':
    #    fn.ClockwiseOrderingOff()

    source = vtkParametricFunctionSource()
    source.SetParametricFunction(fn)
    source.SetUResolution(50)
    source.SetVResolution(50)
    source.SetScalarModeToZ()
    source.Update()
--
    transform = vtkTransform()
    transform.Translate(0.0, 5.0, 15.0)
    transform.RotateX(-90.0)
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputConnection(source.GetOutputPort())
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    return transform_filter.GetOutput()
--
    fn = vtkParametricTorus()
    fn.SetRingRadius(5)
    fn.SetCrossSectionRadius(2)

    source = vtkParametricFunctionSource()
    source.SetParametricFunction(fn)
    source.SetUResolution(50)
    source.SetVResolution(50)
    source.SetScalarModeToZ()
    source.Update()
--
    transform = vtkTransform()
    transform.RotateX(-90.0)
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputConnection(source.GetOutputPort())
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    return transform_filter.GetOutput()
--
    source = vtkPlaneSource()
    source.SetOrigin(-10.0, -10.0, 0.0)
    source.SetPoint2(-10.0, 10.0, 0.0)
    source.SetPoint1(10.0, -10.0, 0.0)
    source.SetXResolution(20)
    source.SetYResolution(20)
--
    transform = vtkTransform()
    transform.Translate(0.0, 0.0, 0.0)
    transform.RotateX(-90.0)
    transform_filter = vtkTransformPolyDataFilter()
    transform_filter.SetInputConnection(source.GetOutputPort())
    transform_filter.SetTransform(transform)
    transform_filter.Update()

    # We have a m x n array of quadrilaterals arranged as a regular tiling in a
--
    tri = vtkTriangleFilter()
    tri.SetInputConnection(transform_filter.GetOutputPort())

    # Pass it though a CleanPolyDataFilter and merge any points which
    # are coincident, or very close
    cleaner = vtkCleanPolyData()
    cleaner.SetInputConnection(tri.GetOutputPort())
    cleaner.SetTolerance(0.005)
    cleaner.Update()

    return cleaner.GetOutput()
--
    source = vtkSphereSource()
    source.SetCenter(0.0, 0.0, 0.0)
    source.SetRadius(10.0)
    source.SetThetaResolution(32)
    source.SetPhiResolution(32)
    source.Update()
--
    source = vtkSuperquadricSource()
    source.SetCenter(0.0, 0.0, 0.0)
    source.SetScale(1.0, 1.0, 1.0)
    source.SetPhiResolution(64)
    source.SetThetaResolution(64)
    source.SetThetaRoundness(1)
--
    tri = vtkTriangleFilter()
    tri.SetInputConnection(source.GetOutputPort())

    # The quadric has nasty discontinuities from the way the edges are generated
    # so let's pass it though a CleanPolyDataFilter and merge any points which
    # are coincident, or very close
    cleaner = vtkCleanPolyData()
    cleaner.SetInputConnection(tri.GetOutputPort())
    cleaner.SetTolerance(0.005)
    cleaner.Update()

    return cleaner.GetOutput()
--
    color_series = vtkColorSeries()
    # Select a color scheme.
    # color_series_enum = color_series.BREWER_DIVERGING_BROWN_BLUE_GREEN_9
    # color_series_enum = color_series.BREWER_DIVERGING_SPECTRAL_10
    # color_series_enum = color_series.BREWER_DIVERGING_SPECTRAL_3
    # color_series_enum = color_series.BREWER_DIVERGING_PURPLE_ORANGE_9
--
    lut = vtkLookupTable()
    color_series.BuildLookupTable(lut, color_series.CATEGORICAL)
    lut.SetNanColor(0, 0, 0, 1)
    return lut


--
    lut = vtkLookupTable()
    color_series.BuildLookupTable(lut, color_series.ORDINAL)
    lut.SetNanColor(0, 0, 0, 1)
    return lut


--
    ctf = vtkColorTransferFunction()
    ctf.SetColorSpaceToDiverging()
    # Cool to warm.
    ctf.AddRGBPoint(0.0, 0.085, 0.532, 0.201)
    ctf.AddRGBPoint(0.5, 0.865, 0.865, 0.865)
    ctf.AddRGBPoint(1.0, 0.758, 0.214, 0.233)
--
    lut = vtkLookupTable()
    lut.SetNumberOfTableValues(table_size)
    lut.Build()

    for i in range(0, table_size):
        rgba = list(ctf.GetColor(float(i) / table_size))
--
    lutr = vtkLookupTable()
    lutr.DeepCopy(lut)
    t = lut.GetNumberOfTableValues() - 1
    rev_range = reversed(list(range(t + 1)))
    for i in rev_range:
        rgba = [0.0] * 3
--
    reverse = vtkReverseSense()

    # Choose a random subset of points.
    mask_pts = vtkMaskPoints()
    mask_pts.SetOnRatio(5)
    mask_pts.RandomModeOn()
    if reverse_normals:
        reverse.SetInputData(src)
        reverse.ReverseCellsOn()
--
    arrow = vtkArrowSource()
    arrow.SetTipResolution(16)
    arrow.SetTipLength(0.3)
    arrow.SetTipRadius(0.1)

    glyph = vtkGlyph3D()
    glyph.SetSourceConnection(arrow.GetOutputPort())
    glyph.SetInputConnection(mask_pts.GetOutputPort())
    glyph.SetVectorModeToUseNormal()
    glyph.SetScaleFactor(scale_factor)
    glyph.SetColorModeToColorByVector()
--
    parser.add_argument('file_name', help='The path to the JSON file e.g. Frog_vtk.json.')
    parser.add_argument('-n', action='store_true', dest='omit_sliders', help='No sliders.')
    parser.add_argument('-t', nargs='+', dest='tissues', action='append', help='Select one or more tissues.')
    args = parser.parse_args()
    return args.file_name, args.view, args.omit_sliders, args.tissues

--
    colors = vtkNamedColors()
    colors.SetColor("ParaViewBkg", [82, 87, 110, 255])

    # Setup render window, renderers, and interactor.
    ren = vtkRenderer()
    ren_win = vtkRenderWindow()
    ren_win.AddRenderer(ren)
    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(ren_win)
    style = vtkInteractorStyleTrackballCamera()
    iren.SetInteractorStyle(style)

    sliders = dict()
    left_step_size = 1.0 / 9
    left_pos_y = 0.275
--
        reader = vtkPolyDataReader()
        reader.SetFileName(parameters['vtk_files'][tissue])
        reader.Update()

        trans = SliceOrder().get(parameters['orientation'][tissue])
        trans.Scale(1, -1, -1)
--
        tf = vtkTransformPolyDataFilter()
        tf.SetInputConnection(reader.GetOutputPort())
        tf.SetTransform(trans)
        tf.SetInputConnection(reader.GetOutputPort())

        normals = vtkPolyDataNormals()
        normals.SetInputConnection(tf.GetOutputPort())
        normals.SetFeatureAngle(60.0)

        mapper = vtkPolyDataMapper()
        mapper.SetInputConnection(normals.GetOutputPort())

        actor = vtkActor()
        actor.SetMapper(mapper)

        actor.GetProperty().SetOpacity(parameters['opacity'][tissue])
        actor.GetProperty().SetDiffuseColor(color_lut.GetTableValue(parameters['indices'][tissue])[:3])
        actor.GetProperty().SetSpecular(0.2)
--
        transform = vtkTransform()
        transform.SetMatrix(camera.GetModelTransformMatrix())
        transform.RotateY(90)
        transform.RotateZ(90)
        camera.SetModelTransformMatrix(transform.GetMatrix())
        ren.ResetCamera()
--
        transform = vtkTransform()
        transform.SetMatrix(camera.GetModelTransformMatrix())
        transform.RotateY(-90)
        transform.RotateZ(90)
        camera.SetModelTransformMatrix(transform.GetMatrix())
        ren.ResetCamera()
--
    cow = vtkCameraOrientationWidget()
    cow.SetParentRenderer(ren)
    if no_sliders:
        # Turn off if you do not want it.
        cow.On()
        cow.EnabledOn()
--
    om = vtkOrientationMarkerWidget()
    om.SetOrientationMarker(axes)
    # Position upper left in the viewport.
    # om.SetViewport(0.0, 0.8, 0.2, 1.0)
    # Position lower left in the viewport.
    om.SetViewport(0, 0, 0.2, 0.2)
--
                        if kk == 'vtk_files':
                            if len(v[kk]) != 17:
                                print(f'Expected seventeen file names.')
                                paths_ok = False
                            # The stem of the file path becomes the key.
                            path_map = dict()
--
        self.si_mat = vtkMatrix4x4()
        self.si_mat.Zero()
        self.si_mat.SetElement(0, 0, 1)
        self.si_mat.SetElement(1, 2, 1)
        self.si_mat.SetElement(2, 1, -1)
        self.si_mat.SetElement(3, 3, 1)
--
        self.is_mat = vtkMatrix4x4()
        self.is_mat.Zero()
        self.is_mat.SetElement(0, 0, 1)
        self.is_mat.SetElement(1, 2, -1)
        self.is_mat.SetElement(2, 1, -1)
        self.is_mat.SetElement(3, 3, 1)
--
        self.lr_mat = vtkMatrix4x4()
        self.lr_mat.Zero()
        self.lr_mat.SetElement(0, 2, -1)
        self.lr_mat.SetElement(1, 1, -1)
        self.lr_mat.SetElement(2, 0, 1)
        self.lr_mat.SetElement(3, 3, 1)
--
        self.rl_mat = vtkMatrix4x4()
        self.rl_mat.Zero()
        self.rl_mat.SetElement(0, 2, 1)
        self.rl_mat.SetElement(1, 1, -1)
        self.rl_mat.SetElement(2, 0, 1)
        self.rl_mat.SetElement(3, 3, 1)
--
        self.hf_mat = vtkMatrix4x4()
        self.hf_mat.Zero()
        self.hf_mat.SetElement(0, 0, -1)
        self.hf_mat.SetElement(1, 1, 1)
        self.hf_mat.SetElement(2, 2, -1)
        self.hf_mat.SetElement(3, 3, 1)
--
        si_trans = vtkTransform()
        si_trans.SetMatrix(self.si_mat)
        self.transform['si'] = si_trans

        is_trans = vtkTransform()
        is_trans.SetMatrix(self.is_mat)
        self.transform['is'] = is_trans

        ap_trans = vtkTransform()
        ap_trans.Scale(1, -1, 1)
        self.transform['ap'] = ap_trans

        pa_trans = vtkTransform()
        pa_trans.Scale(1, -1, -1)
        self.transform['pa'] = pa_trans

        lr_trans = vtkTransform()
        lr_trans.SetMatrix(self.lr_mat)
        self.transform['lr'] = lr_trans

        rl_trans = vtkTransform()
        rl_trans.SetMatrix(self.rl_mat)
        self.transform['rl'] = rl_trans

        hf_trans = vtkTransform()
        hf_trans.SetMatrix(self.hf_mat)
        self.transform['hf'] = hf_trans

        hf_si_trans = vtkTransform()
        hf_si_trans.SetMatrix(self.hf_mat)
        hf_si_trans.Concatenate(self.si_mat)
        self.transform['hfsi'] = hf_si_trans

        hf_is_trans = vtkTransform()
        hf_is_trans.SetMatrix(self.hf_mat)
        hf_is_trans.Concatenate(self.is_mat)
        self.transform['hfis'] = hf_is_trans

        hf_ap_trans = vtkTransform()
        hf_ap_trans.SetMatrix(self.hf_mat)
        hf_ap_trans.Scale(1, -1, 1)
        self.transform['hfap'] = hf_ap_trans

        hf_pa_trans = vtkTransform()
        hf_pa_trans.SetMatrix(self.hf_mat)
        hf_pa_trans.Scale(1, -1, -1)
        self.transform['hfpa'] = hf_pa_trans

        hf_lr_trans = vtkTransform()
        hf_lr_trans.SetMatrix(self.hf_mat)
        hf_lr_trans.Concatenate(self.lr_mat)
        self.transform['hflr'] = hf_lr_trans

        hf_rl_trans = vtkTransform()
        hf_rl_trans.SetMatrix(self.hf_mat)
        hf_rl_trans.Concatenate(self.rl_mat)
        self.transform['hfrl'] = hf_rl_trans

        # Identity
        self.transform['I'] = vtkTransform()

        # Zero
        z_trans = vtkTransform()
        z_trans.Scale(0, 0, 0)
        self.transform['Z'] = z_trans

    def print_transform(self, order):
        """
--
    lut = vtkLookupTable()
    lut.SetNumberOfColors(len(colors))
    lut.SetTableRange(0, len(colors) - 1)
    lut.Build()

    nc = vtkNamedColors()

    for k in indices.keys():
        lut.SetTableValue(indices[k], nc.GetColor4d(colors[k]))

    return lut
--
    axes = vtkAxesActor()
    axes.SetScale(scale)
    axes.SetShaftTypeToCylinder()
    axes.SetXAxisLabelText(xyz_labels[0])
    axes.SetYAxisLabelText(xyz_labels[1])
    axes.SetZAxisLabelText(xyz_labels[2])
--
    cube = vtkAnnotatedCubeActor()
    cube.SetXPlusFaceText(cube_labels[0])
    cube.SetXMinusFaceText(cube_labels[1])
    cube.SetYPlusFaceText(cube_labels[2])
    cube.SetYMinusFaceText(cube_labels[3])
    cube.SetZPlusFaceText(cube_labels[4])
--
    assembly = vtkPropAssembly()
    assembly.AddPart(axes)
    assembly.AddPart(cube)
    return assembly


--
    slider = vtkSliderRepresentation2D()

    slider.SetMinimumValue(properties.value_minimum)
    slider.SetMaximumValue(properties.value_maximum)
    slider.SetValue(properties.value_initial)
    slider.SetTitleText(properties.title)
--
    colors = vtkNamedColors()
    # Set the colors of the slider components.
    # Change the color of the bar.
    slider.GetTubeProperty().SetColor(colors.GetColor3d(properties.bar_color))
    # Change the color of the ends of the bar.
    slider.GetCapProperty().SetColor(colors.GetColor3d(properties.bar_ends_color))
--
    slider_widget = vtkSliderWidget()
    slider_widget.SetRepresentation(slider)

    return slider_widget


--
    colors = vtkNamedColors()

    # Set the background color.
    colors.SetColor("BkgColor", [26, 51, 102, 255])

    # Read a vtk file
--
    hawaii = vtkPolyDataReader()
    hawaii.SetFileName(file_name)
    hawaii.Update()
    bounds = [0.0] * 6
    hawaii.GetOutput().GetBounds(bounds)

    elevation = vtkElevationFilter()
    elevation.SetInputConnection(hawaii.GetOutputPort())
    elevation.SetLowPoint(0, 0, 0)
    elevation.SetHighPoint(0, 0, 1000)
    elevation.SetScalarRange(0, 1000)

--
    hawaiiMapper = vtkDataSetMapper()
    hawaiiMapper.SetInputConnection(elevation.GetOutputPort())
    hawaiiMapper.SetScalarRange(0, 1000)
    hawaiiMapper.ScalarVisibilityOn()
    hawaiiMapper.SetLookupTable(lut)

    hawaiiActor = vtkActor()
    hawaiiActor.SetMapper(hawaiiMapper)

    # Create the RenderWindow, Renderer and both Actors
    #
    ren = vtkRenderer()
    renWin = vtkRenderWindow()
    renWin.AddRenderer(ren)
    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(renWin)

    # Add the actors to the renderer, set the background and size
    #
    ren.AddActor(hawaiiActor)
--
    parser.add_argument('filename', help='honolulu.vtk')
    parser.add_argument('color_scheme', default=0, type=int, nargs='?', help='The particular color scheme to use.')
    args = parser.parse_args()
    return args.filename, args.color_scheme


--
    colors = vtkNamedColors()
    if color_scheme == 1:
        # A lookup table of 256 colours ranging from
        #  deep blue (water) to yellow-white (mountain top)
        #  is used to color map this figure.
        lut = vtkLookupTable()
        lut.SetHueRange(0.7, 0)
        lut.SetSaturationRange(1.0, 0)
        lut.SetValueRange(0.5, 1.0)
    elif color_scheme == 2:
        # Make the lookup table with a preset number of colours.
        colorSeries = vtkColorSeries()
        colorSeries.SetNumberOfColors(8)
        colorSeries.SetColorSchemeName('Hawaii')
        colorSeries.SetColor(0, colors.GetColor3ub("turquoise_blue"))
        colorSeries.SetColor(1, colors.GetColor3ub("sea_green_medium"))
        colorSeries.SetColor(2, colors.GetColor3ub("sap_green"))
--
        lut = vtkLookupTable()
        colorSeries.BuildLookupTable(lut, colorSeries.ORDINAL)
        lut.SetNanColor(1, 0, 0, 1)
    else:
        # Make the lookup using a Brewer palette.
        colorSeries = vtkColorSeries()
        colorSeries.SetNumberOfColors(8)
        colorSeriesEnum = colorSeries.BREWER_DIVERGING_BROWN_BLUE_GREEN_8
        colorSeries.SetColorScheme(colorSeriesEnum)
        lut = vtkLookupTable()
        colorSeries.BuildLookupTable(lut, colorSeries.ORDINAL)
        lut.SetNanColor(1, 0, 0, 1)
    return lut


--
    colors = vtkNamedColors()

    # Set the furniture colors.
    colors.SetColor('Furniture', [204, 204, 153, 255])

    scalarRange = [0.0, 0.0]
--
    aren = vtkRenderer()
    renWin = vtkRenderWindow()
    renWin.AddRenderer(aren)

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(renWin)

    #
    # Read the data.
    #
    reader = vtkStructuredGridReader()
    reader.SetFileName(fileName)
    reader.Update()  # Force a read to occur.
    reader.GetOutput().GetLength()

    if reader.GetOutput().GetPointData().GetScalars():
--
    outlineF = vtkStructuredGridOutlineFilter()
    outlineF.SetInputConnection(reader.GetOutputPort())
    outlineMapper = vtkPolyDataMapper()
    outlineMapper.SetInputConnection(outlineF.GetOutputPort())
    outline = vtkActor()
    outline.SetMapper(outlineMapper)
    outline.GetProperty().SetColor(colors.GetColor3d('LampBlack'))

    #
    # Set up shaded surfaces (i.e., supporting geometry).
--
    doorGeom = vtkStructuredGridGeometryFilter()
    doorGeom.SetInputConnection(reader.GetOutputPort())
    doorGeom.SetExtent(27, 27, 14, 18, 0, 11)
    mapDoor = vtkPolyDataMapper()
    mapDoor.SetInputConnection(doorGeom.GetOutputPort())
    mapDoor.ScalarVisibilityOff()
    door = vtkActor()
    door.SetMapper(mapDoor)
    door.GetProperty().SetColor(colors.GetColor3d('Burlywood'))

    window1Geom = vtkStructuredGridGeometryFilter()
    window1Geom.SetInputConnection(reader.GetOutputPort())
    window1Geom.SetExtent(0, 0, 9, 18, 6, 12)
    mapWindow1 = vtkPolyDataMapper()
    mapWindow1.SetInputConnection(window1Geom.GetOutputPort())
    mapWindow1.ScalarVisibilityOff()
    window1 = vtkActor()
    window1.SetMapper(mapWindow1)
    window1.GetProperty().SetColor(colors.GetColor3d('SkyBlue'))
    window1.GetProperty().SetOpacity(.6)

    window2Geom = vtkStructuredGridGeometryFilter()
    window2Geom.SetInputConnection(reader.GetOutputPort())
    window2Geom.SetExtent(5, 12, 23, 23, 6, 12)
    mapWindow2 = vtkPolyDataMapper()
    mapWindow2.SetInputConnection(window2Geom.GetOutputPort())
    mapWindow2.ScalarVisibilityOff()
    window2 = vtkActor()
    window2.SetMapper(mapWindow2)
    window2.GetProperty().SetColor(colors.GetColor3d('SkyBlue'))
    window2.GetProperty().SetOpacity(.6)

    klower1Geom = vtkStructuredGridGeometryFilter()
    klower1Geom.SetInputConnection(reader.GetOutputPort())
    klower1Geom.SetExtent(17, 17, 0, 11, 0, 6)
    mapKlower1 = vtkPolyDataMapper()
    mapKlower1.SetInputConnection(klower1Geom.GetOutputPort())
    mapKlower1.ScalarVisibilityOff()
    klower1 = vtkActor()
    klower1.SetMapper(mapKlower1)
    klower1.GetProperty().SetColor(colors.GetColor3d('EggShell'))

    klower2Geom = vtkStructuredGridGeometryFilter()
    klower2Geom.SetInputConnection(reader.GetOutputPort())
    klower2Geom.SetExtent(19, 19, 0, 11, 0, 6)
    mapKlower2 = vtkPolyDataMapper()
    mapKlower2.SetInputConnection(klower2Geom.GetOutputPort())
    mapKlower2.ScalarVisibilityOff()
    klower2 = vtkActor()
    klower2.SetMapper(mapKlower2)
    klower2.GetProperty().SetColor(colors.GetColor3d('EggShell'))

    klower3Geom = vtkStructuredGridGeometryFilter()
    klower3Geom.SetInputConnection(reader.GetOutputPort())
    klower3Geom.SetExtent(17, 19, 0, 0, 0, 6)
    mapKlower3 = vtkPolyDataMapper()
    mapKlower3.SetInputConnection(klower3Geom.GetOutputPort())
    mapKlower3.ScalarVisibilityOff()
    klower3 = vtkActor()
    klower3.SetMapper(mapKlower3)
    klower3.GetProperty().SetColor(colors.GetColor3d('EggShell'))

    klower4Geom = vtkStructuredGridGeometryFilter()
    klower4Geom.SetInputConnection(reader.GetOutputPort())
    klower4Geom.SetExtent(17, 19, 11, 11, 0, 6)
    mapKlower4 = vtkPolyDataMapper()
    mapKlower4.SetInputConnection(klower4Geom.GetOutputPort())
    mapKlower4.ScalarVisibilityOff()
    klower4 = vtkActor()
    klower4.SetMapper(mapKlower4)
    klower4.GetProperty().SetColor(colors.GetColor3d('EggShell'))

    klower5Geom = vtkStructuredGridGeometryFilter()
    klower5Geom.SetInputConnection(reader.GetOutputPort())
    klower5Geom.SetExtent(17, 19, 0, 11, 0, 0)
    mapKlower5 = vtkPolyDataMapper()
    mapKlower5.SetInputConnection(klower5Geom.GetOutputPort())
    mapKlower5.ScalarVisibilityOff()
    klower5 = vtkActor()
    klower5.SetMapper(mapKlower5)
    klower5.GetProperty().SetColor(colors.GetColor3d('EggShell'))

    klower6Geom = vtkStructuredGridGeometryFilter()
    klower6Geom.SetInputConnection(reader.GetOutputPort())
    klower6Geom.SetExtent(17, 19, 0, 7, 6, 6)
    mapKlower6 = vtkPolyDataMapper()
    mapKlower6.SetInputConnection(klower6Geom.GetOutputPort())
    mapKlower6.ScalarVisibilityOff()
    klower6 = vtkActor()
    klower6.SetMapper(mapKlower6)
    klower6.GetProperty().SetColor(colors.GetColor3d('EggShell'))

    klower7Geom = vtkStructuredGridGeometryFilter()
    klower7Geom.SetInputConnection(reader.GetOutputPort())
    klower7Geom.SetExtent(17, 19, 9, 11, 6, 6)
    mapKlower7 = vtkPolyDataMapper()
    mapKlower7.SetInputConnection(klower7Geom.GetOutputPort())
    mapKlower7.ScalarVisibilityOff()
    klower7 = vtkActor()
    klower7.SetMapper(mapKlower7)
    klower7.GetProperty().SetColor(colors.GetColor3d('EggShell'))

    hood1Geom = vtkStructuredGridGeometryFilter()
    hood1Geom.SetInputConnection(reader.GetOutputPort())
    hood1Geom.SetExtent(17, 17, 0, 11, 11, 16)
    mapHood1 = vtkPolyDataMapper()
    mapHood1.SetInputConnection(hood1Geom.GetOutputPort())
    mapHood1.ScalarVisibilityOff()
    hood1 = vtkActor()
    hood1.SetMapper(mapHood1)
    hood1.GetProperty().SetColor(colors.GetColor3d('Silver'))

    hood2Geom = vtkStructuredGridGeometryFilter()
    hood2Geom.SetInputConnection(reader.GetOutputPort())
    hood2Geom.SetExtent(19, 19, 0, 11, 11, 16)
    mapHood2 = vtkPolyDataMapper()
    mapHood2.SetInputConnection(hood2Geom.GetOutputPort())
    mapHood2.ScalarVisibilityOff()
    hood2 = vtkActor()
    hood2.SetMapper(mapHood2)
    hood2.GetProperty().SetColor(colors.GetColor3d('Furniture'))

    hood3Geom = vtkStructuredGridGeometryFilter()
    hood3Geom.SetInputConnection(reader.GetOutputPort())
    hood3Geom.SetExtent(17, 19, 0, 0, 11, 16)
    mapHood3 = vtkPolyDataMapper()
    mapHood3.SetInputConnection(hood3Geom.GetOutputPort())
    mapHood3.ScalarVisibilityOff()
    hood3 = vtkActor()
    hood3.SetMapper(mapHood3)
    hood3.GetProperty().SetColor(colors.GetColor3d('Furniture'))

    hood4Geom = vtkStructuredGridGeometryFilter()
    hood4Geom.SetInputConnection(reader.GetOutputPort())
    hood4Geom.SetExtent(17, 19, 11, 11, 11, 16)
    mapHood4 = vtkPolyDataMapper()
    mapHood4.SetInputConnection(hood4Geom.GetOutputPort())
    mapHood4.ScalarVisibilityOff()
    hood4 = vtkActor()
    hood4.SetMapper(mapHood4)
    hood4.GetProperty().SetColor(colors.GetColor3d('Furniture'))

    hood6Geom = vtkStructuredGridGeometryFilter()
    hood6Geom.SetInputConnection(reader.GetOutputPort())
    hood6Geom.SetExtent(17, 19, 0, 11, 16, 16)
    mapHood6 = vtkPolyDataMapper()
    mapHood6.SetInputConnection(hood6Geom.GetOutputPort())
    mapHood6.ScalarVisibilityOff()
    hood6 = vtkActor()
    hood6.SetMapper(mapHood6)
    hood6.GetProperty().SetColor(colors.GetColor3d('Furniture'))

    cookingPlateGeom = vtkStructuredGridGeometryFilter()
    cookingPlateGeom.SetInputConnection(reader.GetOutputPort())
    cookingPlateGeom.SetExtent(17, 19, 7, 9, 6, 6)
    mapCookingPlate = vtkPolyDataMapper()
    mapCookingPlate.SetInputConnection(cookingPlateGeom.GetOutputPort())
    mapCookingPlate.ScalarVisibilityOff()
    cookingPlate = vtkActor()
    cookingPlate.SetMapper(mapCookingPlate)
    cookingPlate.GetProperty().SetColor(colors.GetColor3d('Tomato'))

    filterGeom = vtkStructuredGridGeometryFilter()
    filterGeom.SetInputConnection(reader.GetOutputPort())
    filterGeom.SetExtent(17, 19, 7, 9, 11, 11)
    mapFilter = vtkPolyDataMapper()
    mapFilter.SetInputConnection(filterGeom.GetOutputPort())
    mapFilter.ScalarVisibilityOff()
    sgfilter = vtkActor()
    sgfilter.SetMapper(mapFilter)
    sgfilter.GetProperty().SetColor(colors.GetColor3d('Furniture'))
    #
    # regular streamlines
    #
    line = vtkLineSource()
    line.SetResolution(39)
    line.SetPoint1(0.08, 2.50, 0.71)
    line.SetPoint2(0.08, 4.50, 0.71)
    rakeMapper = vtkPolyDataMapper()
    rakeMapper.SetInputConnection(line.GetOutputPort())
    rake = vtkActor()
    rake.SetMapper(rakeMapper)

    streamers = vtkStreamTracer()
    # streamers.DebugOn()
    streamers.SetInputConnection(reader.GetOutputPort())
    streamers.SetSourceConnection(line.GetOutputPort())
    streamers.SetMaximumPropagation(maxTime)
    streamers.SetInitialIntegrationStep(.5)
--
    streamersMapper = vtkPolyDataMapper()
    streamersMapper.SetInputConnection(streamers.GetOutputPort())
    streamersMapper.SetScalarRange(scalarRange)

    lines = vtkActor()
    lines.SetMapper(streamersMapper)
    lines.GetProperty().SetColor(colors.GetColor3d('Black'))

    aren.TwoSidedLightingOn()

--
    aCamera = vtkCamera()
    aren.SetActiveCamera(aCamera)
    aren.ResetCamera()

    aCamera.SetFocalPoint(3.505, 2.505, 1.255)
    aCamera.SetPosition(3.505, 24.6196, 1.255)
--
    parser.add_argument('filename', help='kitchen.vtk')
    args = parser.parse_args()
    return args.filename


if __name__ == '__main__':
--
    colors = vtkNamedColors()

    fileName = get_program_parameters()

    polyData = ReadPolyData(fileName)

--
    renderer = vtkRenderer()
    renderer.SetBackground(colors.GetColor3d("White"))

    # Create background colors for each viewport.
    backgroundColors = list()
    backgroundColors.append(colors.GetColor3d("Cornsilk"))
--
    camera = vtkCamera()

    normals = vtkPolyDataNormals()
    normals.SetInputData(polyData)
    normals.SetFeatureAngle(30.0)
    for i in range(0, 3):
        if i == 0:
            normals.ComputePointNormalsOff()
--
        normalsPolyData = vtkPolyData()
        normalsPolyData.DeepCopy(normals.GetOutput())

        # mapper
        mapper = vtkPolyDataMapper()
        mapper.SetInputData(normalsPolyData)
        mapper.ScalarVisibilityOff()

        actor = vtkActor()
        actor.SetMapper(mapper)
        actor.GetProperty().SetDiffuseColor(colors.GetColor3d("Peacock"))
        actor.GetProperty().SetDiffuse(.7)
        actor.GetProperty().SetSpecularPower(20)
        actor.GetProperty().SetSpecular(.5)
--
    renwin = vtkRenderWindow()
    renwin.AddRenderer(ren[0])
    renwin.AddRenderer(ren[1])
    renwin.AddRenderer(ren[2])
    renwin.SetWindowName('NormalsDemo')

--
    interactor = vtkRenderWindowInteractor()
    interactor.SetRenderWindow(renwin)

    renwin.SetSize(900, 300)
    ren[0].GetActiveCamera().SetFocalPoint(0, 0, 0)
    ren[0].GetActiveCamera().SetPosition(1, 0, 0)
--
        reader = vtkPLYReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == ".vtp":
        reader = vtkXMLPolyDataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == ".obj":
        reader = vtkOBJReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == ".stl":
        reader = vtkSTLReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == ".vtk":
        reader = vtkXMLPolyDataReader()
        reader.SetFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    elif extension == ".g":
        reader = vtkBYUReader()
        reader.SetGeometryFileName(file_name)
        reader.Update()
        poly_data = reader.GetOutput()
    else:
        # Return a None if the extension is unknown.
--
    colors = vtkNamedColors()

    # This is a simple volume rendering example that
    # uses a vtkFixedPointVolumeRayCastMapper

    # Create the standard renderer, render window
--
    ren1 = vtkRenderer()

    renWin = vtkRenderWindow()
    renWin.AddRenderer(ren1)

    iren = vtkRenderWindowInteractor()
    iren.SetRenderWindow(renWin)

    # Create the reader for the data.
    reader = vtkStructuredPointsReader()
    reader.SetFileName(fileName)

    # Create transfer mapping scalar value to opacity.
    opacityTransferFunction = vtkPiecewiseFunction()
    opacityTransferFunction.AddPoint(20, 0.0)
    opacityTransferFunction.AddPoint(255, 0.2)

    # Create transfer mapping scalar value to color.
    colorTransferFunction = vtkColorTransferFunction()
    colorTransferFunction.AddRGBPoint(0.0, 0.0, 0.0, 0.0)
    colorTransferFunction.AddRGBPoint(64.0, 1.0, 0.0, 0.0)
    colorTransferFunction.AddRGBPoint(128.0, 0.0, 0.0, 1.0)
    colorTransferFunction.AddRGBPoint(192.0, 0.0, 1.0, 0.0)
    colorTransferFunction.AddRGBPoint(255.0, 0.0, 0.2, 0.0)
--
    volumeProperty = vtkVolumeProperty()
    volumeProperty.SetColor(colorTransferFunction)
    volumeProperty.SetScalarOpacity(opacityTransferFunction)
    volumeProperty.ShadeOn()
    volumeProperty.SetInterpolationTypeToLinear()

--
    volumeMapper = vtkFixedPointVolumeRayCastMapper()
    volumeMapper.SetInputConnection(reader.GetOutputPort())

    # The volume holds the mapper and the property and
    # can be used to position/orient the volume.
    volume = vtkVolume()
    volume.SetMapper(volumeMapper)
    volume.SetProperty(volumeProperty)

    ren1.AddVolume(volume)
    ren1.SetBackground(colors.GetColor3d('Wheat'))
--
    parser.add_argument('filename', help='ironProt.vtk')
    args = parser.parse_args()
    return args.filename


if __name__ == '__main__':
